{
  "version": 3,
  "sources": ["api/index.js", "api/wasm-featuredetect.js", "api/wonderland.js"],
  "sourcesContent": ["import { simd, threads } from './wasm-featuredetect.js';\n\nexport * from './wonderland.js';\n\n/**\n * Finds whether simd & threading are supported or not\n *\n * @returns {Object} An object containing boolean for simd and thread\n */\nasync function detectFeatures() {\n    let [simdSupported, threadsSupported] =  await Promise.all([simd(), threads()]);\n    if(simdSupported) {\n        console.log(\"WASM SIMD is supported\");\n    } else {\n        console.warn(\"WASM SIMD is not supported\");\n    }\n    if(threadsSupported) {\n        if (self.crossOriginIsolated) {\n            console.log(\"WASM Threads is supported\");\n        } else {\n            console.warn(\"WASM Threads is supported, but the page is not crossOriginIsolated, therefore thread support is disabled.\");\n        }\n    } else {\n        console.warn(\"WASM Threads is not supported\");\n    }\n\n    threadsSupported = threadsSupported && self.crossOriginIsolated;\n    return {\n        simdSupported,\n        threadsSupported\n    };\n}\n\n/**\n * @typedef {Object} LoadRuntimeOptions\n * @property {boolean} simd If `true`, forces the runtime to load the SIMD-compatible version.\n *     If `undefined`, performs browser feature detection to check whether SIMD is supported or not\n * @property {boolean} threads If `true`, forces the runtime to load the threads-compatible version.\n *     If `undefined`, performs browser feature detection to check whether threads are supported or not\n */\n\n/**\n * Load the runtime using the WASM and JS files\n *\n * @param {LoadRuntimeOptions} options Options to modify the loading behaviour\n *\n * @returns {Promise<void>} A promise that resolves when the engine is\n *     ready to be used\n */\nexport async function loadRuntime(runtime, options = {}) {\n    const { simdSupported, threadsSupported } = await detectFeatures();\n    const { simd = simdSupported, threads = threadsSupported } = options;\n\n    const filename = `${runtime}${(simd ? '-simd' : '')}${(threads ? '-threads' : '')}`;\n    const r = await fetch(filename + \".wasm\")\n    const wasm = await r.arrayBuffer();\n    return new Promise((res) => {\n      window.Module = {\n          worker:`${filename}.worker.js`,\n          wasm\n      };\n      window.Module.ready = function() {\n        window._wl_application_start();\n        res();\n      }\n      const s = document.createElement('script');\n      s.type = 'text/javascript';\n      s.src = `${filename}.js`;\n      document.body.append(s);\n    });\n}\n", "export const bigInt=()=>(async e=>{try{return(await WebAssembly.instantiate(e)).instance.exports.b(BigInt(0))===BigInt(0)}catch(e){return!1}})(new Uint8Array([0,97,115,109,1,0,0,0,1,6,1,96,1,126,1,126,3,2,1,0,7,5,1,1,98,0,0,10,6,1,4,0,32,0,11])),bulkMemory=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,3,1,0,1,10,14,1,12,0,65,0,65,0,65,0,252,10,0,0,11])),exceptions=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,6,64,7,26,11,11])),multiValue=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,6,1,96,0,2,127,127,3,2,1,0,10,8,1,6,0,65,0,65,0,11])),mutableGlobals=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,2,8,1,1,97,1,98,3,127,1,6,6,1,127,1,65,0,11,7,5,1,1,97,3,1])),referenceTypes=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,7,1,5,0,208,112,26,11])),saturatedFloatToInt=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,12,1,10,0,67,0,0,0,0,252,0,26,11])),signExtensions=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,8,1,6,0,65,0,192,26,11])),simd=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])),tailCall=async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,6,1,4,0,18,0,11])),threads=()=>(async e=>{try{return\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(e)}catch(e){return!1}})(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]));\n", "\nconst MISALIGNED_MSG = \"Misaligned pointer: please report a bug\";\n/* Component class instances per type to avoid GC */\nlet ComponentCache = {};\n/* Object class instances per type to avoid GC */\nlet ObjectCache = [];\n/* Component properties to exclude when cloning, see addComponent() */\nconst EXCLUDED_COMPONENT_PROPERTIES = ['_id', '_manager', 'type', '_type', 'active'];\n\n/**\n * Wonderland Engine API\n * @namespace WL\n */\n\n/**\n * @typedef CustomParameter\n * @type {object}\n * @property {Type} type Parameter type\n * @property {*} [default] Default value, depending on type.\n * @property {string[]} values Values for {@link Type.Enum}\n */\n/**\n * Register a custom JavaScript component type\n *\n * @param {string} name Name of the component\n * @param {object} params Dict of param names to {@link CustomParameter}\n * @param {Component} object Object containing functions for the component type\n *\n * @example\n * registerComponent('my-new-type', {\n *  myParam: {type: Type.Float, default: 42.0},\n * }, {\n *  init: function() {},\n *  start: function() {},\n *  update: function(dt) {},\n *  onActivate: function() {},\n *  onDeactivate: function() {},\n *  // Since 0.9.0:\n *  onDestroy: function() {},\n * });\n */\nfunction registerComponent(name, params, object) {\n    _WL.registerComponent(name, params, object);\n};\n\n/**\n * Component parameter type enum\n * @enum {number}\n */\nconst Type = {\n    /**\n     * **Bool**:\n     *\n     * Appears in the editor as checkbox.\n     */\n    Bool: 1<<1,\n\n    /**\n     * **Int**:\n     *\n     * Appears in the editor as int input field.\n     */\n    Int: 1<<2,\n\n    /**\n     * **Float**:\n     *\n     * Appears in the editor as float input field.\n     */\n    Float: 1<<3,\n\n    /**\n     * **String / Text**:\n     *\n     * Appears in the editor as text input field.\n     */\n    String: 1<<4,\n\n    /**\n     * **Enumeration**:\n     *\n     * Appears in the editor as dropdown with given values.\n     * If parameters is enum, a `values` parameter needs to be\n     * specified for the parameter as well.\n     *\n     * @example\n     *     camera: {type: Type.Enum, values: ['auto', 'back', 'front'], default: 'auto'},\n     */\n    Enum: 1<<5,\n\n    /**\n     * **Object reference**:\n     *\n     * Appears in the editor as object resource selection dropdown\n     * with object picker.\n     */\n    Object: 1<<6,\n\n    /**\n     * **Mesh reference**:\n     *\n     * Appears in the editor as mesh resource selection dropdown.\n     */\n    Mesh: 1<<7,\n\n    /**\n     * **Texture reference**:\n     *\n     * Appears in the editor as texture resource selection dropdown.\n     */\n    Texture: 1<<8,\n\n    /**\n     * **Material reference**:\n     *\n     * Appears in the editor as material resource selection dropdown.\n     */\n    Material: 1<<9,\n\n    /**\n     * **Animation reference**:\n     *\n     * Appears in the editor as animation resource selection dropdown.\n     */\n    Animation: 1<<10,\n\n    /**\n     * **Skin reference**:\n     *\n     * Appears in the editor as skin resource selection dropdown.\n     */\n    Skin: 1<<11,\n};\nexport { Type };\n\n/**\n * Collider type enum for {@link CollisionComponent}\n * @enum {number}\n */\nconst Collider = {\n    /**\n     * **Sphere Collider**:\n     *\n     * Simplest and most performant collision shape. If this type is set on a\n     * {@link CollisionComponent}, only the first component of\n     * {@link CollisionComponent#extents} will be used to determine the radius.\n     */\n    Sphere: 0,\n\n    /**\n     * **Axis Aligned Bounding Box Collider**:\n     *\n     * Box that is always aligned to XYZ axis. It cannot be rotated but is more\n     * efficient than {@link Collider.Box}.\n     */\n    AxisAlignedBox: 1,\n\n    /**\n     * **Aligned Bounding Box Collider**:\n     *\n     * Box that matches the object's rotation and translation correctly. This\n     * is the least efficient collider and should only be chosen over\n     * {@link Collider.Sphere} and {@link Collider.AxisAlignedBox} if really\n     * necessary.\n     */\n    Box: 2\n};\nexport { Collider };\n\n/**\n * Alignment type enum for {@link TextComponent}\n * @enum {number}\n */\nconst Alignment = {\n    /** Text start is at object origin */\n    Left: 1,\n\n    /** Text center is at object origin */\n    Center: 2,\n\n    /** Text end is at object origin */\n    Right: 3\n};\nexport { Alignment };\n\n/**\n * Justification type enum for {@link TextComponent}\n * @enum {number}\n */\nconst Justification = {\n    /** Text line is at object origin */\n    Line: 1,\n\n    /** Text middle is at object origin */\n    Middle: 2,\n\n    /** Text top is at object origin */\n    Top: 3,\n\n    /** Text bottom is at object origin */\n    Bottom: 4\n};\nexport { Justification };\n\n/**\n * Effect type enum for {@link TextComponent}\n * @enum {number}\n */\n const TextEffect = {\n    /** Text is rendered normally */\n    None: 0,\n\n    /** Text is rendered with an outline */\n    Outline: 1\n};\nexport { TextEffect };\n\n/**\n * Input type enum for {@link InputComponent}\n * @enum {number}\n */\nconst InputType = {\n    /** Head input */\n    Head: 0,\n\n    /** Left eye input */\n    EyeLeft: 1,\n\n    /** Right eye input */\n    EyeRight: 2,\n\n    /** Left controller input */\n    ControllerLeft: 3,\n\n    /** Right controller input */\n    ControllerRight: 4,\n\n    /** Left ray input */\n    RayLeft: 5,\n\n    /** Right ray input */\n    RayRight: 6,\n};\nexport { InputType };\n\n/**\n * Light type enum for {@link LightComponent}\n * @enum {number}\n */\nconst LightType = {\n    /** Point light */\n    Point: 1,\n\n    /** Spot light */\n    Spot: 2,\n\n    /** Sun light / Directional light */\n    Sun: 3,\n};\nexport { LightType };\n\n/**\n * Animation state of {@link AnimationComponent}\n * @enum {number}\n */\nconst AnimationState = {\n    /** Animation is currently playing */\n    Playing: 1,\n\n    /** Animation is paused and will continue at current playback\n    * time on {@link AnimationComponent#play} */\n    Paused: 2,\n\n    /** Animation is stopped */\n    Stopped: 3\n};\nexport { AnimationState };\n\n/**\n * Rigid body force mode for {@link PhysXComponent#addForce} and {@link PhysXComponent#addTorque}.\n * @enum {number}\n *\n * [PhysX API Reference](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxapi/files/structPxForceMode.html)\n */\nconst ForceMode = {\n    /** Apply as force */\n    Force: 0,\n\n    /** Apply as impulse */\n    Impulse: 1,\n\n    /** Apply as velocity change, mass dependent */\n    VelocityChange: 2,\n\n    /** Apply as mass dependent force */\n    Acceleration: 3\n};\nexport { ForceMode };\n\n/**\n * Collision callback event type\n * @enum {number}\n */\nconst CollisionEventType = {\n    /** Touch/contact detected, collision */\n    Touch: 0,\n\n    /** Touch/contact lost, uncollide */\n    TouchLost: 1,\n\n    /** Touch/contact with trigger detected */\n    TriggerTouch: 2,\n\n    /** Touch/contact with trigger lost */\n    TriggerTouchLost: 3,\n};\nexport { CollisionEventType };\n\n/**\n * Rigid body {@link PhysXComponent#shape|shape}.\n * @enum {number}\n *\n * [PhysX SDK Guide](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Geometry.html#geometry-types)\n */\nconst Shape = {\n    /** No shape */\n    None: 0,\n\n    /** Sphere shape */\n    Sphere: 1,\n\n    /** Capsule shape */\n    Capsule: 2,\n\n    /** Box shape */\n    Box: 3,\n\n    /** Plane shape */\n    Plane: 4,\n\n    /** Convex mesh shape */\n    ConvexMesh: 5,\n\n    /** Triangle mesh shape */\n    TriangleMesh: 6,\n};\nexport { Shape };\n\n/**\n * Canvas element that Wonderland Engine renders to\n * @type {HTMLCanvasElement}\n */\nlet canvas = null;\n\n/**\n * Current WebXR session or {@link null} if no session active\n * @type {XRSession}\n */\nlet xrSession = null;\n/**\n * @callback xrSessionStartCallback\n * @param {XRSession} session WebXR session that started\n */\n/**\n * @callback xrSessionEndCallback\n */\n/**\n * List of functions to call if a WebXR session is started\n * @type {xrSessionStartCallback[]}\n */\nconst onXRSessionStart = [ (s) => { xrSession = s; } ];\n/**\n * List of functions to call if a WebXR session ends\n * @type {xrSessionEndCallback[]}\n */\nconst onXRSessionEnd = [ () => { xrSession = null; } ];\n\n/**\n * @callback xrSupportCallback\n * @param {string} type Type of session which is supported/not supported. Either `\"vr\"` or `\"ar\"`\n * @param {boolean} supported Whether given session type is supported\n */\n/**\n * List of functions to call once VR/AR support has been determined.\n * @type {xrSupportCallback[]}\n *\n * Will be called once for AR and once for VR independent of support for each.\n * This allows you to notify the user of both cases: support and missing support of XR.\n * See the `supported` parameter of the callback, which indicates support.\n */\nlet onXRSupported = [\n  (type, supported) => {\n    if(type == 'ar') arSupported = supported;\n    if(type == 'vr') vrSupported = supported;\n  }\n];\n\n/**\n * @callback sceneLoadedCallback\n */\n/**\n * List of functions to call once the main scene has been loaded\n * @type {sceneLoadedCallback[]}\n */\nlet onSceneLoaded = [];\n\n/**\n * Whether AR is supported by the browser\n *\n * `undefined` until support could be determined\n */\nlet arSupported = undefined;\n/**\n * Whether VR is supported by the browser\n *\n * `undefined` until support could be determined\n */\nlet vrSupported = undefined;\n/**\n * Current main scene\n * @type {Scene}\n */\nlet scene = undefined;\n/**\n * Physics, only available when physx is enabled in the runtime\n * @type {Physics}\n */\nlet physics = undefined;\n\nlet _images = [];\nlet _sceneLoadedCallback = [];\nlet _tempMem = null;\nlet _tempMemSize = 0;\nlet _tempMemFloat = null;\nlet _tempMemInt = null;\nlet _tempMemUint32 = null;\nlet _tempMemUint16 = null;\nlet _tempMemUint8 = null;\n\n/** Initialize API resources, called by the engine automatically. */\nfunction init() {\n    scene = new Scene();\n    /* For internal testing, we provide compatibility with DOM-less execution */\n    canvas = (typeof document === 'undefined') ? null : document.getElementById('canvas');\n\n    ComponentCache = {};\n    /* Object class instances per type to avoid GC */\n    ObjectCache = [];\n\n    /* Target memory for JS API functions that return arrays */\n    allocateTempMemory(1024);\n}\n\n/**\n * Reset the runtime state, including:\n *     - Component cache\n *     - Images\n *     - Callbacks\n */\nfunction reset() {\n    ComponentCache = {};\n    ObjectCache.length = 0;\n    _images.length = 0;\n    _sceneLoadedCallback.length = 0;\n    _WL.reset();\n}\n\n/** Initialize API resources, called by the engine automatically, if\n * PhysX is enabled. */\nfunction _initPhysics() {\n    physics = new Physics();\n}\n\nfunction allocateTempMemory(size) {\n    console.log(\"Allocating temp mem:\", size);\n    _tempMemSize = size;\n    if(_tempMem) _free(_tempMem);\n    _tempMem = _malloc(_tempMemSize);\n    updateTempMemory();\n}\n\nfunction requireTempMem(size) {\n    if(_tempMemSize >= size) return;\n    /* Grow in 1kb increments */\n    allocateTempMemory(Math.ceil(size/1024)*1024);\n}\n\nfunction updateTempMemory() {\n    _tempMemFloat = new Float32Array(HEAP8.buffer,_tempMem,_tempMemSize >> 2);\n    _tempMemInt = new Int32Array(HEAP8.buffer,_tempMem,_tempMemSize >> 2);\n    _tempMemUint32 = new Uint32Array(HEAP8.buffer,_tempMem,_tempMemSize >> 2);\n    _tempMemUint16 = new Uint16Array(HEAP8.buffer,_tempMem,_tempMemSize >> 1);\n    _tempMemUint8 = new Uint8Array(HEAP8.buffer,_tempMem,_tempMemSize);\n}\n\n/**\n * Returns a uint8 buffer view on temporary WASM memory.\n *\n * **Note**: this method might allocate if the requested memory is bigger\n * than the current temporary memory allocated.\n *\n * @param {number} count The number of **elements** required\n * @returns {Uint8Array} A {@link TypedArray} over the WASM memory\n */\nfunction getTempBufferU8(count) {\n    requireTempMem(count);\n    return _tempMemUint8;\n}\n\n/**\n * Returns a uint16 buffer view on temporary WASM memory.\n *\n * **Note**: this method might allocate if the requested memory is bigger\n * than the current temporary memory allocated.\n *\n * @param {number} count The number of **elements** required\n * @returns {Uint16Array} A {@link TypedArray} over the WASM memory\n */\nfunction getTempBufferU16(count) {\n    requireTempMem(count * 2);\n    return _tempMemUint16;\n}\n\n/**\n * Returns a uint32 buffer view on temporary WASM memory.\n *\n * **Note**: this method might allocate if the requested memory is bigger\n * than the current temporary memory allocated.\n *\n * @param {number} count The number of **elements** required.\n * @returns {Uint32Array} A {@link TypedArray} over the WASM memory\n */\nfunction getTempBufferU32(count) {\n    requireTempMem(count * 4);\n    return _tempMemUint32;\n}\n\n/**\n * Returns a int32 buffer view on temporary WASM memory.\n *\n * **Note**: this method might allocate if the requested memory is bigger\n * than the current temporary memory allocated.\n *\n * @param {number} count The number of **elements** required\n * @returns {Int32Array} A {@link TypedArray} over the WASM memory\n */\nfunction getTempBufferI32(count) {\n    requireTempMem(count * 4);\n    return _tempMemInt;\n}\n\n/**\n * Returns a float32 buffer view on temporary WASM memory.\n *\n * **Note**: this method might allocate if the requested memory is bigger\n * than the current temporary memory allocated.\n *\n * @param {number} count The number of **elements** required\n * @returns {Float32Array} A {@link TypedArray} over the WASM memory\n */\nfunction getTempBufferF32(count) {\n    requireTempMem(count * 4);\n    return _tempMemFloat;\n}\n\nexport {\n    registerComponent,\n\n    canvas,\n    scene,\n    xrSession,\n    onXRSessionStart,\n    onXRSessionEnd,\n    onXRSupported,\n    onSceneLoaded,\n    arSupported,\n    vrSupported,\n    physics,\n    _images,\n    _sceneLoadedCallback,\n    textures,\n\n    init,\n    reset,\n    _initPhysics,\n    updateTempMemory,\n};\n\n/**\n * Provides global scene functionality like raycasting.\n */\nclass Scene {\n    constructor() {\n        this._rayHit = _malloc(4*(3*4+3*4+4+2)+4);\n        this._hit = new RayHit(this._rayHit);\n\n        /* Hidden property, list of functions to call after a\n         * frame has been rendered */\n        this.onPreRender = [];\n        this.onPostRender = [];\n    }\n\n    /**\n     * @returns {ViewComponent[]} currently active view components\n     */\n    get activeViews() {\n        const count = _wl_scene_get_active_views(_tempMem, 16);\n\n        const views = [];\n        const viewTypeIndex = $Object._typeIndexFor(\"view\");\n        for(let i = 0; i < count; ++i) {\n            views.push(new ViewComponent(viewTypeIndex, _tempMemInt[i]));\n        }\n\n        return views;\n    }\n\n    /**\n     * Cast a ray through the scene and find intersecting objects.\n     *\n     * The resulting ray hit will contain up to **4** closest ray hits,\n     * sorted by increasing distance.\n     *\n     * @param {number[]} o Ray origin\n     * @param {number[]} d Ray direction\n     * @param {number} group Collision group to filter by: only objects that are\n     *        part of given group are considered for raycast.\n     *\n     * @note The returned {@link RayHit} object is owned by the Scene instance and\n     *       will be reused with the next {@link Scene#rayCast} call.\n     */\n    rayCast(o, d, group) {\n        _wl_scene_ray_cast(\n            o[0], o[1], o[2],\n            d[0], d[1], d[2],\n            group, this._rayHit);\n        return this._hit;\n    }\n\n    /**\n     * Add object to the scene\n     *\n     * @param {$Object} parent Parent object or {@link null}\n     * @returns {$Object} newly created object\n     */\n    addObject(parent) {\n        const parentId = parent ? parent.objectId : 0;\n        const objectId = _wl_scene_add_object(parentId);\n        return $Object._wrapObject(objectId);\n    }\n\n    /**\n     * Batch-add objects to the scene\n     *\n     * Will provide better performance for adding multiple objects (e.g. > 16)\n     * than calling {@link Scene#addObject} repeatedly in a loop.\n     *\n     * By providing upfront information of how many objects will be required,\n     * the engine is able to batch-allocate the required memory rather than\n     * convervatively grow the memory in small steps.\n     *\n     * **Experimental:** This API might change in upcoming versions.\n     *\n     * @param {number} count Number of objects to add\n     * @param {$Object} parent Parent object or {@link null}, default {@link null}\n     * @param {number} componentCountHint Hint for how many components in total will\n     *      be added to the created objects afterwards, default `0`.\n     * @returns {$Object[]} newly created objects\n     */\n    addObjects(count, parent, componentCountHint) {\n        const parentId = parent ? parent.objectId : 0;\n        requireTempMem(count*2);\n        const actualCount = _wl_scene_add_objects(parentId, count, componentCountHint || 0, _tempMem, _tempMemSize >> 1);\n        const ids = _tempMemUint16.subarray(0, actualCount);\n        const objects = Array.from(ids, $Object._wrapObject);\n        return objects;\n    }\n\n    /**\n     * Pre-allocate memory for a given amount of objects and components\n     *\n     * Will provide better performance for adding objects later with {@link Scene#addObject}\n     * and {@link Scene#addObjects}\n     *\n     * By providing upfront information of how many objects will be required,\n     * the engine is able to batch-allocate the required memory rather than\n     * convervatively grow the memory in small steps.\n     *\n     * **Experimental:** This API might change in upcoming versions.\n     *\n     * @param {number} objectCount Number of objects to add\n     * @param {Object.<string, number>} componentCountPerType Amount of components to\n     *      allocate for {@link $Object#addComponent}, e.g. `{mesh: 100, collision: 200, \"my-comp\": 100}`\n     * @since 0.8.10\n     */\n    reserveObjects(objectCount, componentCountPerType) {\n        componentCountPerType = componentCountPerType || {};\n        const jsManagerIndex = $Object._typeIndexFor('js');\n        let countsPerTypeIndex = _tempMemInt.subarray();\n        countsPerTypeIndex.fill(0);\n        for(const e of Object.entries(componentCountPerType)) {\n            const typeIndex = $Object._typeIndexFor(e[0]);\n            countsPerTypeIndex[(typeIndex < 0) ? jsManagerIndex : typeIndex] += e[1];\n        }\n        _wl_scene_reserve_objects(objectCount, _tempMem);\n    }\n\n    /**\n     * Set the background clear color\n     *\n     * @param {number[]} color new clear color (RGBA)\n     * @since 0.8.5\n     */\n    set clearColor(color) {\n        _wl_scene_set_clearColor(color[0], color[1], color[2], color[3]);\n    }\n\n    /**\n     * Set whether to clear the color framebuffer before drawing.\n     *\n     * This function is useful if an external framework (e.g. an AR tracking\n     * framework) is responsible for drawing a camera frame before Wonderland\n     * Engine draws the scene on top of it.\n     *\n     * @param {boolean} b Whether to enable color clear.\n     * @since 0.9.4\n     */\n    set colorClearEnabled(b) {\n        _wl_scene_enableColorClear(b);\n    }\n\n    /**\n     * Load a scene file (.bin)\n     *\n     * Will replace the currently active scene with the one loaded\n     * from given file. It is assumed that JavaScript components required by\n     * the new scene were registered in advance.\n     *\n     * @param filename Path to the .bin file\n     */\n    load(filename) {\n        const strLen = lengthBytesUTF8(filename) + 1;\n        const ptr = _malloc(strLen);\n        stringToUTF8(filename, ptr, strLen);\n        _wl_load_scene(ptr);\n        _free(ptr);\n    }\n\n    /**\n     * Load an external 3D file (.gltf, .glb)\n     *\n     * Loads and parses the gltf file and its images and appends the result\n     * to scene.\n     *\n     * @example\n     *    WL.scene.append(filename).then(root => {\n     *        // root contains the loaded scene\n     *    });\n     *\n     * In case the `loadGltfExtensions` option is set to true, the response\n     * will be an object containing both the root of the loaded scene and\n     * any glTF extensions found on nodes, meshes and the root of the file.\n     *\n     * @example\n     *    WL.scene.append(filename, { loadGltfExtensions: true }).then(({root, extensions}) => {\n     *        // root contains the loaded scene\n     *\n     *        // extensions.root contains any extensions at the root of glTF document\n     *        const rootExtensions = extensions.root;\n     *\n     *        // extensions.mesh and extensions.node contain extensions indexed by Object id\n     *        const childObject = root.children[0];\n     *        const meshExtensions = root.meshExtensions[childObject.objectId];\n     *        const nodeExtensions = root.nodeExtensions[childObject.objectId];\n     *\n     *        // extensions.idMapping contains a mapping from glTF node index to Object id\n     *    });\n     *\n     * @param filename Path to the .gltf or .glb file\n     * @param options Additional options for loading\n     * @returns {Promise<$Object>|Promise<Object>} Root of the loaded scene\n     */\n    append(filename, options) {\n        options = options || {};\n        const loadGltfExtensions = !!options.loadGltfExtensions;\n\n        const strLen = lengthBytesUTF8(filename) + 1;\n        const ptr = _malloc(strLen);\n        stringToUTF8(filename, ptr, strLen);\n        const callback = _sceneLoadedCallback.length;\n        const promise = new Promise((resolve, reject) => {\n            _sceneLoadedCallback[callback] = {\n                success: (id, extensions) => {\n                    const root = $Object._wrapObject(id);\n                    resolve(extensions ? { root, extensions } : root);\n                },\n                error: () => reject()\n            };\n        });\n\n        _wl_append_scene(ptr, loadGltfExtensions, callback);\n        _free(ptr);\n        return promise;\n    }\n\n    /**\n     * Unmarshalls the GltfExtensions from an Uint32Array\n     *\n     * @param {Uint32Array} data Array containing the gltf extension data\n     * @returns {Object}\n     */\n    _unmarshallGltfExtensions(data) {\n        const extensions = {\n            root: {},\n            mesh: {},\n            node: {},\n            idMapping: {},\n        };\n\n        let index = 0;\n        const readString = () => {\n            const strPtr = data[index++];\n            const strLen = data[index++];\n            return _WL.UTF8ViewToString(strPtr, strPtr + strLen);\n        }\n\n        const idMappingSize = data[index++];\n        const idMapping = new Array(idMappingSize);\n        for(let i = 0; i < idMappingSize; ++i) {\n            idMapping[i] = data[index++];\n        }\n        extensions.idMapping = idMapping;\n\n        const meshExtensionsSize = data[index++];\n        for(let i = 0; i < meshExtensionsSize; ++i) {\n            const objectId = data[index++];\n            extensions.mesh[idMapping[objectId]] = JSON.parse(readString());\n        }\n        const nodeExtensionsSize = data[index++];\n        for(let i = 0; i < nodeExtensionsSize; ++i) {\n            const objectId = data[index++];\n            extensions.node[idMapping[objectId]] = JSON.parse(readString());\n        }\n        const rootExtensionsStr = readString();\n        if(rootExtensionsStr) {\n            extensions.root = JSON.parse(rootExtensionsStr);\n        }\n\n        return extensions;\n    }\n\n    /**\n     * Reset the scene\n     *\n     * This method deletes all used and allocated objects, and components.\n     */\n    reset() {\n        _wl_scene_reset();\n    }\n};\nexport { Scene };\n\n/**\n * Native component\n *\n * Provides access to a native component instance of a specified component type\n */\nclass Component {\n    constructor(managerIndex = -1, id = -1) {\n        this._manager = managerIndex;\n        this._id = id;\n        this._object = null;\n        this._type = null;\n    }\n\n    /**\n     * @returns {string} the name of this component's type\n     */\n    get type() {\n        return this._type || $Object._typeNameFor(this._manager);\n    }\n\n    /**\n     * @returns {$Object} The object this component is attached to\n     */\n    get object() {\n        if(!this._object) {\n            const objectId = _wl_component_get_object(this._manager, this._id);\n            this._object = $Object._wrapObject(objectId);\n        }\n        return this._object;\n    }\n\n    /**\n     * Set whether this component is active\n     *\n     * Activating/deactivating a component comes at a small cost of reordering\n     * components in the respective component manager. This function therefore\n     * is not a trivial assignment.\n     *\n     * Does nothing if the component is already activated/deactivated.\n     *\n     * @param {boolean} active New active state\n     */\n    set active(active) {\n        _wl_component_setActive(this._manager, this._id, active);\n    }\n\n    /**\n     * @returns {boolean} Whether this component is active\n     */\n    get active() {\n        return _wl_component_isActive(this._manager, this._id) != 0;\n    }\n\n    /**\n     * Remove this component from its objects and destroy it.\n     *\n     * It is best practice to set the component to `null` after,\n     * to ensure it does not get used later.\n     *\n     * @example\n     *    c.destroy();\n     *    c = null;\n     * @since 0.9.0\n     */\n    destroy() {\n        _wl_component_remove(this._manager, this._id);\n        this._manager = undefined;\n        this._id = undefined;\n    }\n\n    /**\n     * Checks equality by comparing whether the wrapped native component ids\n     * and component manager types are equal.\n     *\n     * @param {?Component} otherComponent Component to check equality with\n     * @returns {boolean} Whether this component equals the given component\n     */\n    equals(otherComponent) {\n        if(!otherComponent) return false;\n        return this._manager == otherComponent._manager && this._id == otherComponent._id;\n    }\n};\nexport { Component };\n\n/**\n * Native collision component\n *\n * Provides access to a native collision component instance\n */\nclass CollisionComponent extends Component {\n\n    /**\n     * @returns {Collider} Collision component collider\n     */\n    get collider() {\n        return _wl_collision_component_get_collider(this._id);\n    }\n\n    /**\n     * Set collision component collider\n     *\n     * @param {Collider} collider Collider of the collision component.\n     */\n    set collider(collider) {\n        _wl_collision_component_set_collider(this._id, collider);\n    }\n\n    /**\n     * If {@link CollisionComponent#collider} returns {@link Collider.Sphere}, only the first\n     * component of the returned vector is used.\n     *\n     * @returns {number[]} Collision component extents\n    */\n    get extents() {\n        return new Float32Array(HEAPF32.buffer, _wl_collision_component_get_extents(this._id), 3);\n    }\n\n    /**\n     * Set collision component extents\n     *\n     * If {@link CollisionComponent#collider} returns {@link Collider.Sphere}, only the first\n     * component of the passed vector is used.\n     *\n     * @param {number[]} extents Extents of the collision component, expects a\n     *      3 component array.\n     */\n    set extents(extents) {\n        this.extents.set(extents);\n    }\n\n    /**\n     * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}\n     * or the group in {@link Scene#rayCast}.\n     *\n     * Colliders that have no common groups will not overlap with each other. If a collider\n     * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.\n     *\n     * Each bit represents belonging to a group, see example.\n     *\n     * @example\n     *    // c belongs to group 2\n     *    c.group = (1 << 2);\n     *\n     *    // c belongs to group 0\n     *    c.group = (1 << 0);\n     *\n     *    // c belongs to group 0 *and* 2\n     *    c.group = (1 << 0) | (1 << 2);\n     *\n     *    (c.group & (1 << 2)) != 0; // true\n     *    (c.group & (1 << 7)) != 0; // false\n     *\n     * @returns {number} collision component group\n     */\n    get group() {\n        return _wl_collision_component_get_group(this._id);\n    }\n\n    /**\n     * Set collision component group\n     *\n     * @param {number} group Group mask of the collision component\n     */\n    set group(group) {\n        _wl_collision_component_set_group(this._id, group);\n    }\n\n    /**\n     * Query overlapping objects\n     *\n     * @returns {CollisionComponent[]} Collision components overlapping this collider.\n     */\n    queryOverlaps() {\n        const count = _wl_collision_component_query_overlaps(this._id, _tempMem, _tempMemSize >> 1);\n        let overlaps = new Array(count);\n        for(let i = 0; i < count; ++i) {\n            overlaps[i] = new CollisionComponent(this._manager, _tempMemUint16[i]);\n        }\n        return overlaps;\n    }\n};\nexport { CollisionComponent };\n\n/**\n * Native text component\n *\n * Provides access to a native text component instance\n */\nclass TextComponent extends Component {\n\n    /**\n     * @returns {Alignment} Text component alignment\n     */\n    get alignment() {\n        return _wl_text_component_get_horizontal_alignment(this._id);\n    }\n\n    /**\n     * Set text component alignment\n     *\n     * @param {Alignment} alignment Alignment for the text component.\n     */\n    set alignment(alignment) {\n        _wl_text_component_set_horizontal_alignment(this._id, alignment);\n    }\n\n    /**\n     * @returns {Justification} Text component justification\n     */\n    get justification() {\n        return _wl_text_component_get_vertical_alignment(this._id);\n    }\n\n    /**\n     * Set text component justification\n     *\n     * @param {Justification} justification Justification for the text component.\n     */\n    set justification(justification) {\n        _wl_text_component_set_vertical_alignment(this._id, justification);\n    }\n\n    /**\n     * @returns {number} Text component character spacing\n     */\n     get characterSpacing() {\n        return _wl_text_component_get_character_spacing(this._id);\n    }\n\n    /**\n     * Set text component character spacing\n     *\n     * @param {number} spacing Character spacing for the text component\n     */\n    set characterSpacing(spacing) {\n        _wl_text_component_set_character_spacing(this._id, spacing);\n    }\n\n    /**\n     * @returns {number} Text component line spacing\n     */\n     get lineSpacing() {\n        return _wl_text_component_get_line_spacing(this._id);\n    }\n\n    /**\n     * Set text component line spacing\n     *\n     * @param {number} spacing Line spacing for the text component\n     */\n    set lineSpacing(spacing) {\n        _wl_text_component_set_line_spacing(this._id, spacing);\n    }\n\n    /**\n     * @returns {TextEffect} Text component effect\n     */\n     get effect() {\n        return _wl_text_component_get_effect(this._id);\n    }\n\n    /**\n     * Set text component effect\n     *\n     * @param {TextEffect} effect Effect for the text component\n     */\n    set effect(effect) {\n        _wl_text_component_set_effect(this._id, effect);\n    }\n\n    /**\n     * @returns {string} Text component text\n     */\n    get text() {\n        return UTF8ToString(_wl_text_component_get_text(this._id));\n    }\n\n    /**\n     * Set text component text\n     *\n     * @param {string} text Text of the text component\n     */\n    set text(text) {\n        const strLen = lengthBytesUTF8(text) + 1;\n        const ptr = _malloc(strLen);\n        stringToUTF8(text, ptr, strLen);\n        _wl_text_component_set_text(this._id, ptr);\n        _free(ptr);\n    }\n\n    /**\n     * Set material to render the text with\n     *\n     * @param {Material} material New material\n     */\n    set material(material) {\n        _wl_text_component_set_material(this._id, material ? material._index : 0);\n    }\n\n    /**\n     * @returns {?Material} Material used to render the text\n     */\n    get material() {\n        return Material.wrap(_wl_text_component_get_material(this._id));\n    }\n\n};\nexport { TextComponent };\n\n/**\n * Native view component\n *\n * Provides access to a native view component instance\n */\nclass ViewComponent extends Component {\n\n    /**\n     * @returns {Float32Array} Projection matrix\n     */\n    get projectionMatrix() {\n        return new Float32Array(HEAPF32.buffer,\n            _wl_view_component_get_projection_matrix(this._id), 16);\n    }\n\n    /**\n     * @returns {number} ViewComponent near clipping plane value\n     */\n    get near() {\n        return _wl_view_component_get_near(this._id);\n    }\n\n    /**\n     * Set near clipping plane distance for the view\n     *\n     * If an XR session is active, the change will apply in the\n     * following frame, otherwise the change is immediate.\n     *\n     * @param {number} near Near depth value\n     */\n    set near(near) {\n        _wl_view_component_set_near(this._id, near);\n    }\n\n    /**\n     * @returns {number} ViewComponent far clipping plane value\n     */\n    get far() {\n        return _wl_view_component_get_far(this._id);\n    }\n\n    /**\n     * Set far clipping plane distance for the view\n     *\n     * If an XR session is active, the change will apply in the\n     * following frame, otherwise the change is immediate.\n     *\n     * @param {number} far Near depth value\n     */\n    set far(far) {\n        _wl_view_component_set_far(this._id, far);\n    }\n\n    /**\n     * Get field of view for the view\n     *\n     * If an XR session is active, this returns the field of view reported by\n     * the device, regardless of the fov that was set.\n     *\n     * @returns {number} ViewComponent horizontal field of view in degrees\n     */\n     get fov() {\n        return _wl_view_component_get_fov(this._id);\n    }\n\n    /**\n     * Set field of view for the view\n     *\n     * If an XR session is active, the field of view reported by the device is\n     * used and this value is ignored. After the XR session ends, the new value\n     * is applied.\n     *\n     * @param {number} fov Horizontal field of view in degrees\n     */\n    set fov(fov) {\n        _wl_view_component_set_fov(this._id, fov);\n    }\n};\nexport { ViewComponent };\n\n/**\n * Native input component\n *\n * Provides access to a native input component instance\n */\nclass InputComponent extends Component {\n\n    /**\n     * @returns {InputType} Input component type\n     */\n    get inputType() {\n        return _wl_input_component_get_type(this._id);\n    }\n\n    /**\n     * Set input component type\n     *\n     * @params {InputType} New input component type\n     */\n    set inputType(type) {\n        _wl_input_component_set_type(this._id, type);\n    }\n\n    /**\n     * @returns {?XRInputSource} WebXR Device API input source associated\n     *          with this input component, if type {@link InputType.ControllerLeft}\n     *          or {@link InputType.ControllerRight}.\n     */\n    get xrInputSource() {\n        if(xrSession) {\n            for(let inputSource of xrSession.inputSources) {\n                if(inputSource.handedness == this.handedness) {\n                    return inputSource;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {?string} 'left', 'right' or {@link null} depending on the {@link InputComponent#inputType}.\n     */\n    get handedness() {\n        const inputType = this.inputType;\n        if(inputType == InputType.ControllerRight || inputType == InputType.RayRight || inputType == InputType.EyeRight)\n            return 'right';\n        if(inputType == InputType.ControllerLeft || inputType == InputType.RayLeft || inputType == InputType.EyeLeft)\n            return 'left';\n\n        return null;\n    }\n};\nexport { InputComponent };\n\n/**\n * Native light component\n *\n * Provides access to a native light component instance\n */\nclass LightComponent extends Component {\n\n    /** @returns {Float32Array} View on the light color */\n    get color() {\n        return new Float32Array(HEAPF32.buffer, _wl_light_component_get_color(this._id), 4);\n    }\n\n    /** @returns {LightType} Light type */\n    get lightType() {\n        return _wl_light_component_get_type(this._id);\n    }\n\n    /**\n     * Set light type\n     *\n     * @param {LightType} lightType Type of the light component.\n     */\n    set lightType(t) {\n        return _wl_light_component_set_type(this._id, t);\n    }\n};\nexport { LightComponent };\n\n/**\n * Native animation component\n *\n * Provides access to a native animation component instance\n */\nclass AnimationComponent extends Component {\n\n    /**\n     * Set animation to play\n     *\n     * Make sure to {@link Animation#retarget} the animation to affect the\n     * right objects.\n     *\n     * @param {Animation} animation to play\n     */\n    set animation(anim) {\n        _wl_animation_component_set_animation(this._id, anim._index);\n    }\n\n    /** @returns {Animation} animation set for this component */\n    get animation() {\n        return new Animation(_wl_animation_component_get_animation(this._id));\n    }\n\n    /**\n     * Set play count. Set to `0` to loop indefinitely.\n     *\n     * @param {number} playCount Number of times to repeat the animation\n     */\n    set playCount(playCount) {\n        _wl_animation_component_set_playCount(this._id, playCount);\n    }\n\n    /** @returns {number} Number of times the animation is played */\n    get playCount() {\n        return _wl_animation_component_get_playCount(this._id);\n    }\n\n    /**\n     * Set speed. Set to negative values to run the animation backwards.\n     *\n     * Setting speed has an immediate effect for the current frame's update\n     * and will continue with the speed from the current point in the animation.\n     *\n     * @param {number} speed New speed at which to play the animation.\n     * @since 0.8.10\n     */\n    set speed(speed) {\n        _wl_animation_component_set_speed(this._id, speed);\n    }\n\n    /**\n     * @returns {number} Speed factor at which the animation is played\n     * @since 0.8.10\n     */\n    get speed() {\n        return _wl_animation_component_get_speed(this._id);\n    }\n\n    /** Play animation */\n    play() {\n        _wl_animation_component_play(this._id);\n    }\n\n    /** Stop animation */\n    stop() {\n        _wl_animation_component_stop(this._id);\n    }\n\n    /** Pause animation */\n    pause() {\n        _wl_animation_component_pause(this._id);\n    }\n\n    /** @returns {AnimationState} Current playing state of the animation */\n    get state() {\n        return _wl_animation_component_state(this._id);\n    }\n\n};\nexport { AnimationComponent };\n\n/**\n * Native mesh component\n *\n * Provides access to a native mesh component instance\n */\nclass MeshComponent extends Component {\n    /**\n     * Set material to render the mesh with\n     *\n     * @param {?Material} material Material to render the mesh with\n     */\n    set material(material) {\n        _wl_mesh_component_set_material(this._id, material ? material._index : 0);\n    }\n\n    /** @returns {?Material} Material used to render the mesh */\n    get material() {\n        return Material.wrap(_wl_mesh_component_get_material(this._id));\n    }\n\n    /** @returns {?Mesh} Mesh rendered by this component */\n    get mesh() {\n        return new Mesh(_wl_mesh_component_get_mesh(this._id));\n    }\n\n    /**\n     * Set mesh to rendered with this component\n     *\n     * @param {?Mesh} mesh Mesh rendered by this component\n     */\n    set mesh(mesh) {\n        _wl_mesh_component_set_mesh(this._id, mesh._index);\n    }\n\n    /** @returns {?Skin} Skin for this mesh component */\n    get skin() {\n        return new Skin(_wl_mesh_component_get_skin(this._id));\n    }\n\n    /**\n     * Set skin to transform this mesh component\n     *\n     * @param {?Skin} skin Skin to use for rendering skinned meshes\n     */\n    set skin(skin) {\n        _wl_mesh_component_set_skin(this._id, skin._index);\n    }\n};\nexport { MeshComponent };\n\n/**\n * Native physx rigid body component\n *\n * Provides access to a native mesh component instance.\n * Only available when using physx enabled runtime, see \"Project Settings > Runtime\".\n */\nclass PhysXComponent extends Component {\n    /**\n     * Set whether this rigid body is static\n     *\n     * Setting this property only takes effect once the component\n     * switches from inactive to active.\n     *\n     * @param {boolean} b Whether the rigid body should be static\n     */\n    set static(b) {\n        _wl_physx_component_set_static(this._id, b);\n    }\n\n    /**\n     * Whether this rigid body is static\n     *\n     * This property returns whether the rigid body is *effectively*\n     * static. If static property was set while the rigid body was\n     * active, it will not take effect until the rigid body is set\n     * inactive and active again. Until the component is set inactive,\n     * this getter will return whether the rigidbody is actually\n     * static.\n     */\n    get static() {\n        return !!_wl_physx_component_get_static(this._id);\n    }\n\n    /**\n     * Set whether this rigid body is kinematic\n     *\n     * @param {boolean} b Whether the rigid body should be kinematic\n     */\n    set kinematic(b) {\n        _wl_physx_component_set_kinematic(this._id, b);\n    }\n\n    /**\n     * @returns {boolean} Whether this rigid body is kinematic\n     */\n    get kinematic() {\n        return !!_wl_physx_component_get_kinematic(this._id);\n    }\n\n    /**\n     * Set the shape for collision detection\n     *\n     * @param {Shape} s New shape\n     * @since 0.8.5\n     */\n    set shape(s) {\n        _wl_physx_component_set_shape(this._id, s);\n    }\n\n    /**\n     * The shape for collision detection\n     * @returns {Shape} Currently set shape\n     */\n    get shape() {\n        return _wl_physx_component_get_shape(this._id);\n    }\n\n    /**\n     * Set additional data for the shape.\n     *\n     * Retrieved only from {@link PhysXComponent#shapeData}.\n     * @since 0.8.10\n     */\n    set shapeData(d) {\n        if(d == null || !([Shape.TriangleMesh, Shape.ConvexMesh].includes(this.shape)))\n            return;\n        _wl_physx_component_set_shape_data(this._id, d.index);\n    }\n\n    /**\n     * Additional data for the shape.\n     *\n     * `null` for {@link Shape} values: `None`, `Sphere`, `Capsule`, `Box`, `Plane`.\n     * `{index: n}` for `TriangleMesh` and `ConvexHull`.\n     *\n     * This data is currently only for passing onto or creating other\n     * {@link PhysXComponent}s.\n     * @since 0.8.10\n     */\n    get shapeData() {\n        if(!([Shape.TriangleMesh, Shape.ConvexMesh].includes(this.shape)))\n            return null;\n        return { index: _wl_physx_component_get_shape_data(this._id) };\n    }\n\n    /**\n     * Set the shape extents for collision detection\n     *\n     * @param {number[]} e New extents for the shape\n     * @since 0.8.5\n     */\n    set extents(e) {\n        this.extents.set(e);\n    }\n\n    /**\n     * The shape extents for collision detection\n     */\n    get extents() {\n        const ptr = _wl_physx_component_get_extents(this._id);\n        return new Float32Array(HEAPF32.buffer, ptr, 3);\n    }\n\n    /**\n     * Get staticFriction\n     */\n    get staticFriction() {\n        return _wl_physx_component_get_staticFriction(this._id);\n    }\n\n    /**\n     * Set staticFriction\n     * @param {number} v New staticFriction\n     */\n    set staticFriction(v) {\n        _wl_physx_component_set_staticFriction(this._id, v);\n    }\n\n    /**\n     * Get dynamicFriction\n     */\n    get dynamicFriction() {\n        return _wl_physx_component_get_dynamicFriction(this._id);\n    }\n\n    /**\n     * Set dynamicFriction\n     * @param {number} v New dynamicDamping\n     */\n    set dynamicFriction(v) {\n        _wl_physx_component_set_dynamicFriction(this._id, v);\n    }\n\n    /**\n     * Get bounciness\n     * @since 0.9.0\n     */\n    get bounciness() {\n        return _wl_physx_component_get_bounciness(this._id);\n    }\n\n    /**\n     * Set bounciness\n     * @param {number} v New bounciness\n     * @since 0.9.0\n     */\n    set bounciness(v) {\n        _wl_physx_component_set_bounciness(this._id, v);\n    }\n\n    /**\n     * Get linearDamping\n     */\n    get linearDamping() {\n        return _wl_physx_component_get_linearDamping(this._id);\n    }\n\n    /**\n     * Set linearDamping\n     * @param {number} v New linearDamping\n     */\n    set linearDamping(v) {\n        _wl_physx_component_set_linearDamping(this._id, v);\n    }\n\n    /**\n     * Get angularDamping\n     */\n    get angularDamping() {\n        return _wl_physx_component_get_angularDamping(this._id);\n    }\n\n    /**\n     * Set angularDamping\n     * @param {number} v New angularDamping\n     */\n    set angularDamping(v) {\n        _wl_physx_component_set_angularDamping(this._id, v);\n    }\n\n    /**\n     * Set linear velocity\n     *\n     * [PhysX Manual - \"Velocity\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)\n     *\n     * Has no effect, if the component is not active.\n     *\n     * @param {number[]} v New linear velocity\n     */\n    set linearVelocity(v) {\n        _wl_physx_component_set_linearVelocity(this._id, v[0], v[1], v[2]);\n    }\n\n    /**\n     * @returns {Float32Array} Linear velocity or `[0, 0, 0]`\n     *      if the component is not active.\n     */\n    get linearVelocity() {\n        _wl_physx_component_get_linearVelocity(this._id, _tempMem);\n        return new Float32Array(HEAPF32.buffer, _tempMem, 3);\n    }\n\n    /**\n     * Set angular velocity\n     *\n     * [PhysX Manual - \"Velocity\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)\n     *\n     * Has no effect, if the component is not active.\n     *\n     * @param {number[]} v New angular velocity\n     */\n    set angularVelocity(v) {\n        _wl_physx_component_set_angularVelocity(this._id, v[0], v[1], v[2]);\n    }\n\n    /**\n     * @returns {Float32Array} Angular velocity or `[0, 0, 0]`\n     *      if the component is not active.\n     */\n    get angularVelocity() {\n        _wl_physx_component_get_angularVelocity(this._id, _tempMem);\n        return new Float32Array(HEAPF32.buffer, _tempMem, 3);\n    }\n\n    /**\n     * Set mass\n     *\n     * [PhysX Manual - \"Mass Properties\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)\n     *\n     * @param {number} m New mass\n     */\n    set mass(m) {\n        _wl_physx_component_set_mass(this._id, m);\n    }\n\n    /** @returns {number} mass */\n    get mass() {\n        return _wl_physx_component_get_mass(this._id);\n    }\n\n    /**\n     * Set mass space interia tensor\n     *\n     * [PhysX Manual - \"Mass Properties\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)\n     *\n     * Has no effect, if the component is not active.\n     *\n     * @param {number[]} v New mass space interatia tensor\n     */\n    set massSpaceInteriaTensor(v) {\n        _wl_physx_component_set_massSpaceInertiaTensor(this._id, v[0], v[1], v[2]);\n    }\n\n    /**\n     * Apply a force\n     *\n     * [PhysX Manual - \"Applying Forces and Torques\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)\n     *\n     * Has no effect, if the component is not active.\n     *\n     * @param {number[]} f Force vector\n     * @param {number[]} m Force mode, see {@link ForceMode}, default `Force`.\n     * @param {number[]} localForce Whether the force vector is in local space, default `false`.\n     * @param {number[]} p Position to apply force at, default is center of mass.\n     * @param {number[]} local Whether position is in local space, default `false`.\n     */\n    addForce(f, m, localForce, p, local) {\n        m = m || ForceMode.Force;\n        if(!p) {\n            _wl_physx_component_addForce(this._id, f[0], f[1], f[2], m, !!localForce);\n        } else {\n            _wl_physx_component_addForceAt(this._id, f[0], f[1], f[2], m, !!localForce, p[0], p[1], p[2], !!local);\n        }\n    }\n\n    /**\n     * Apply torque\n     *\n     * [PhysX Manual - \"Applying Forces and Torques\"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)\n     *\n     * Has no effect, if the component is not active.\n     *\n     * @param {number[]} f Force vector\n     * @param {number[]} m Force mode, see {@link ForceMode}, default `Force`.\n     */\n    addTorque(f, m) {\n        m = m || ForceMode.Force;\n        _wl_physx_component_addTorque(this._id, f[0], f[1], f[2], m);\n    }\n\n    /**\n     * @callback collisionCallback\n     * @param {CollisionEventType} type Type of the event\n     * @param {PhysXComponent} other Other component that was (un)collided with\n     */\n    /**\n     * Add on collision callback\n     *\n     * @param {collisionCallback} callback Function to call when this rigid body\n     *        (un)collides with any other.\n     *\n     * @example\n     *  let rigidBody = this.object.getComponent('physx');\n     *  rigidBody.onCollision(function(type, other) {\n     *      // Ignore uncollides\n     *      if(type == CollisionEventType.TouchLost) return;\n     *\n     *      // Take damage on collision with enemies\n     *      if(other.object.name.startsWith('enemy-')) {\n     *          this.applyDamage(10);\n     *      }\n     *  }.bind(this));\n     */\n    onCollision(callback) {\n        return this.onCollisionWith(this, callback);\n    }\n\n    /**\n     * Add filtered on collision callback\n     *\n     * @param {PhysXComponent} otherComp Component for which callbacks will\n     *        be triggered. If you pass this component, the method is equivalent to\n     *        {@link PhysXComponent#onCollision}.\n     * @param {collisionCallback} callback Function to call when this rigid body\n     *        (un)collides with `otherComp`.\n     * @returns {number} Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.\n     */\n    onCollisionWith(otherComp, callback) {\n        physics._callbacks[this._id] = physics._callbacks[this._id] || [];\n        physics._callbacks[this._id].push(callback);\n        return _wl_physx_component_addCallback(this._id, otherComp._id || this._id);\n    }\n\n    /**\n     * Remove a collision callback added with {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.\n     * @param {number} callbackId Callback id as returned by {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.\n     * @throws When the callback does not belong to the component\n     * @throws When the callback does not exist\n     */\n    removeCollisionCallback(callbackId) {\n        const r = _wl_physx_component_removeCallback(this._id, callbackId);\n        /* r is the amount of object to remove from the end of the\n         * callbacks array for this object */\n        if(r) physics._callbacks[this._id].splice(-r);\n    }\n};\n\nfor(const prop of [\n    'static', 'extents', 'staticFriction', 'dynamicFriction', 'bounciness',\n    'linearDamping', 'angularDamping', 'shape', 'shapeData', 'kinematic',\n    'linearVelocity', 'angularVelocity', 'mass'])\n{\n    Object.defineProperty(PhysXComponent.prototype, prop, {enumerable: true});\n}\nexport { PhysXComponent };\n\n/**\n * Access to the physics scene\n */\nclass Physics {\n    constructor() {\n        this._rayHit = _malloc(4*(3*4+3*4+4+2)+4);\n        this._hit = new RayHit(this._rayHit);\n        this._callbacks = {};\n    }\n\n    /**\n     * Cast a ray through the physics scene and find intersecting objects.\n     *\n     * The resulting ray hit will contain **up to 4** closest ray hits,\n     * sorted by increasing distance.\n     *\n     * @param {number[]} o Ray origin\n     * @param {number[]} d Ray direction\n     * @param {number} group Collision group to filter by: only objects that are\n     *        part of given group are considered for raycast.\n     * @param {number} maxDistance Maximum ray distance, default `100.0`.\n     *\n     * @note The returned {@link RayHit} object is owned by the Physics instance and\n     *       will be reused with the next {@link Physics#rayCast} call.\n     */\n    rayCast(o, d, group, maxDistance) {\n        if(typeof maxDistance === 'undefined') maxDistance = 100.0;\n        _wl_physx_ray_cast(\n            o[0], o[1], o[2],\n            d[0], d[1], d[2],\n            group, maxDistance||100, this._rayHit);\n        return this._hit;\n    }\n\n    _callCollisionCallback(a, index, type, b) {\n        physics._callbacks[a][index](type,\n            new PhysXComponent($Object._typeIndexFor('physx'), b));\n    }\n};\nexport { Physics };\n\n/**\n * Wrapper around a native mesh data\n */\nclass Mesh {\n\n    /**\n     * Size of a vertex in float elements\n     * @deprecated Replaced with {@link Mesh#attribute()} and {@link MeshAttributeAccessor}\n     */\n    static get VERTEX_FLOAT_SIZE() { return 3 + 3 + 2; }\n    /**\n     * Size of a vertex in bytes\n     * @deprecated Replaced with {@link Mesh#attribute()} and {@link MeshAttributeAccessor}\n     */\n    static get VERTEX_SIZE() { return this.VERTEX_FLOAT_SIZE*4; }\n\n    /**\n     * Position attribute offsets in float elements\n     * @deprecated Replaced with {@link Mesh#attribute()} and {@link MeshAttribute#Position}\n     */\n    static get POS() { return { X: 0, Y: 1, Z: 2 }; }\n    /**\n     * Texture coordinate attribute offsets in float elements\n     * @deprecated Replaced with {@link Mesh#attribute()} and {@link MeshAttribute#TextureCoordinate}\n     */\n    static get TEXCOORD() { return { U: 3, V: 4 }; }\n    /**\n     * Normal attribute offsets in float elements\n     * @deprecated Replaced with {@link Mesh#attribute()} and {@link MeshAttribute#Normal}\n     */\n    static get NORMAL() { return { X: 5, Y: 6, Z: 7 }; }\n\n    /**\n     * Constructor\n     *\n     * @param {object} params Either a mesh index to wrap or set of parameters to create a new mesh\n     * @param {number} params.vertexCount Number of vertices to allocate\n     * @param {boolean} params.skinned `true` if the mesh should be skinned. Defaults to false.\n     * @param {number[]} params.vertexData (deprecated, use `vertexCount` instead and set data\n     *      with {@link Mesh#attribute} instead.) Interleaved vertex data values. A vertex is a\n     *      set of 8 float values:\n     *          - 0-2 Position\n     *          - 3-5 Normal\n     *          - 6-8 Texture Coordinate\n     * @param {?number[]} params.indexData Index data values\n     * @param {?MeshIndexType} params.indexType Index type, `null` if not indexed\n     */\n    constructor(params) {\n        if(typeof(params) === 'object') {\n            if(!params.vertexCount && params.vertexData) {\n                params.vertexCount = params.vertexData.length/WL.Mesh.VERTEX_FLOAT_SIZE;\n            }\n            if(!params.vertexCount) throw new Error(\"Missing parameter 'vertexCount'\");\n\n            let indexData = null;\n            let indexDataSize = 0;\n            if(params.indexData) {\n                const indexType = params.indexType || WL.MeshIndexType.UnsignedShort;\n                indexDataSize = params.indexData.length*indexType;\n                indexData = _malloc(indexDataSize);\n                /* Copy the index data into wasm memory */\n                switch(indexType) {\n                    case MeshIndexType.UnsignedByte:\n                        HEAPU8.set(params.indexData, indexData);\n                        break;\n                    case MeshIndexType.UnsignedShort:\n                        HEAPU16.set(params.indexData, indexData >> 1);\n                        break;\n                    case MeshIndexType.UnsignedInt:\n                        HEAPU32.set(params.indexData, indexData >> 2);\n                        break;\n                }\n            }\n\n            const { skinned = false } = params;\n\n            this._index = _wl_mesh_create(indexData, indexDataSize,\n                params.indexType, params.vertexCount, skinned);\n\n            if(params.vertexData) {\n                const positions = this.attribute(WL.MeshAttribute.Position);\n                const normals = this.attribute(WL.MeshAttribute.Normal);\n                const textureCoordinates = this.attribute(WL.MeshAttribute.TextureCoordinate);\n\n                for(let i = 0; i < params.vertexCount; ++i) {\n                    const start = i*WL.Mesh.VERTEX_FLOAT_SIZE;\n                    positions.set(i, params.vertexData.subarray(start, start + 3));\n                    textureCoordinates.set(i, params.vertexData.subarray(start + 3, start + 5));\n                    normals.set(i, params.vertexData.subarray(start + 5, start + 8));\n                }\n            }\n        } else {\n            this._index = params;\n        }\n    }\n\n    /**\n     * @returns {Float32Array} Vertex data (read-only)\n     * @deprecated Replaced with {@link attribute()}\n     */\n    get vertexData() {\n        let ptr = _wl_mesh_get_vertexData(this._index, _tempMem);\n        return new Float32Array(HEAPF32.buffer, ptr, WL.Mesh.VERTEX_FLOAT_SIZE*HEAPU32[_tempMem/4]);\n    }\n\n    /**\n     * @returns {number} Number of vertices in this mesh\n     */\n    get vertexCount() {\n        return _wl_mesh_get_vertexCount(this._index);\n    }\n\n    /**\n     * @returns {Uint8Array|Uint16Array|Uint32Array} Index data (read-only) or\n     *          {@link null} if the mesh is not indexed\n     */\n    get indexData() {\n        let ptr = _wl_mesh_get_indexData(this._index, _tempMem, _tempMem + 4);\n        if(ptr === null) return null;\n\n        const indexCount = HEAPU32[_tempMem/4];\n        const indexSize = HEAPU32[_tempMem/4 + 1];\n        switch(indexSize) {\n            case MeshIndexType.UnsignedByte:\n                return new Uint8Array(HEAPU8.buffer, ptr, indexCount);\n            case MeshIndexType.UnsignedShort:\n                return new Uint16Array(HEAPU16.buffer, ptr, indexCount);\n            case MeshIndexType.UnsignedInt:\n                return new Uint32Array(HEAPU32.buffer, ptr, indexCount);\n        }\n    }\n\n    /**\n     * Updates the bounding sphere to match new vertex positions.\n     */\n    update() {\n        _wl_mesh_update(this._index);\n    }\n\n    /**\n     * Mesh bounding sphere.\n     *\n     * @param {?Float32Array} out Preallocated array to write into,\n     *  to avoid garbage, otherwise will allocate a new {@link Float32Array}.\n     *\n     * @example\n     *  const sphere = new Float32Array(4);\n     *  for(...) {\n     *      mesh.getBoundingSphere(sphere);\n     *      ...\n     *  }\n     *\n     * @returns {Float32Array} Bounding sphere, 0-2 sphere origin, 3 radius.\n     *\n     * If the position data is changed, call {@link Mesh#update} to update the\n     * bounding sphere.\n     */\n    getBoundingSphere(out) {\n        out = out || new Float32Array(4);\n        _wl_mesh_get_boundingSphere(this._index, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n        out[3] = _tempMemFloat[3];\n        return out;\n    }\n\n    /**\n     * Get an attribute accessor to retrieve or modify data of give attribute\n     * @param {MeshAttribute} attr Attribute to get access to\n     * @returns {?MeshAttributeAccessor} attr Attribute to get access to or `null`,\n     *      if mesh does not have this attribute.\n     *\n     * If there are no shaders in the scene that use `TextureCoordinate` for example,\n     * no meshes will have the `TextureCoordinate` attribute.\n     *\n     * For flexible reusable components, take this into account that only `Position`\n     * is guaranteed to be present at all time.\n     */\n    attribute(attr) {\n        if(typeof(attr) != 'number')\n            throw new TypeError(\"Expected number, but got \" + typeof(attr));\n        _wl_mesh_get_attribute(this._index, attr, _tempMem);\n        if(_tempMemUint32[0] == 255) return null;\n\n        const a = new MeshAttributeAccessor(attr);\n        a._attribute = _tempMemUint32[0];\n        a._offset = _tempMemUint32[1];\n        a._stride = _tempMemUint32[2];\n        a._formatSize = _tempMemUint32[3];\n        a._componentCount = _tempMemUint32[4];\n        a.length = this.vertexCount;\n        return a;\n    }\n\n    /**\n     * Destroy and free the meshes memory.\n     *\n     * It is best practice to set the mesh variable to `null` after calling\n     * destroy to prevent accidental use:\n     *\n     * @example\n     *   mesh.destroy();\n     *   mesh = null;\n     *\n     * Accessing the mesh after destruction behaves like accessing an empty\n     * mesh.\n     *\n     * @since 0.9.0\n     */\n    destroy() {\n        _wl_mesh_destroy(this._index);\n    }\n};\nexport { Mesh };\n\n/**\n * An iterator over a mesh vertex attribute\n *\n * @example\n *   const mesh = this.object.getComponent('mesh').mesh;\n *   const positions = mesh.attribute(WL.MeshAttribute.Position);\n *\n *   const temp = new Float32Array(3);\n *   for(int i = 0; i < positions.length; ++i) {\n *       // pos will reference temp and thereby not allocate additional\n *       // JavaScript garbage, which would cause a perf spike when collected.\n *       const pos = positions.get(i, temp);\n *       // scale position by 2 on X axis only\n *       pos[0] *= 2.0f;\n *       positions.set(i, pos);\n *   }\n */\nclass MeshAttributeAccessor {\n\n    constructor(type = MeshAttribute.Position) {\n        this._attribute = -1;\n        this._offset = 0;\n        this._stride = 0;\n        this._formatSize = 0;\n        this._componentCount = 0;\n        this.length = 0;\n\n        /**\n         * Function to allocate temporary WASM memory. This is cached to avoid\n         * any conditional during get/set.\n         * @type {Function}\n         * @private\n         */\n        this._tempBufferGetter = undefined;\n        /**\n         * Class to instantiate an ArrayBuffer to get/set values.\n         * @type {Function}\n         * @private\n         */\n        this._bufferType = undefined; /* ArrayBuffer class tight to the data format */\n\n        switch(type) {\n            case MeshAttribute.Position: case MeshAttribute.Normal:\n            case MeshAttribute.TextureCoordinate: case MeshAttribute.Tangent:\n            case MeshAttribute.Color: case MeshAttribute.JointWeight:\n            case MeshAttribute.SecondaryJointWeight:\n                this._bufferType = Float32Array;\n                this._tempBufferGetter = getTempBufferF32;\n                break;\n            case MeshAttribute.JointId: case MeshAttribute.SecondaryJointId:\n                this._bufferType = Uint16Array;\n                this._tempBufferGetter = getTempBufferU16;\n                break;\n            default:\n                throw new Error(`Invalid attribute accessor type: ${type}`);\n        }\n    }\n\n    /**\n     * Create a new TypedArray to hold this attribute values.\n     *\n     * This method is useful to create a view to hold the data to\n     * pass to {@link MeshAttributeAccessor.get} and {@link MeshAttributeAccessor.set}\n     *\n     * Example:\n     *\n     * ```js\n     * const vertexCount = 4;\n     * const positionAttribute = mesh.attribute(MeshAttributes.Position);\n     *\n     * // A position has 3 floats per vertex. Thus, positions has length 3 * 4.\n     * const positions = positionAttribute.createArray(vertexCount);\n     * ```\n     *\n     * @param {number} count The number of **vertices** expected.\n     * @returns {Uint8Array|Uint16Array|Uint32Array|Int32Array|Float32Array} A TypedArray\n     *    with the appropriate format to access the data\n     */\n    createArray(count = 1) {\n        count = count > this.length ? this.length : count;\n        return new this._bufferType(count * this._componentCount);\n    }\n\n    /**\n     * Get attribute element\n     * @param {number} i Index\n     * @param {number[]|Float32Array|Uint32Array} out Preallocated array to write into,\n     *      to avoid garbage, otherwise will allocate a new TypedArray.\n     *\n     * `out.length` needs to be a multiple of the attributes component count, see\n     * {@link MeshAttribute}. If `out.length` is more than one multiple, it will be\n     * filled with the next n attribute elements, which can reduce overhead\n     * of this call.\n     */\n    get(index, out) {\n        out = out || this.createArray();\n        if(out.length % this._componentCount !== 0)\n            throw new Error(`out.length, ${v.length} is not a multiple of the attribute vector components, ${this._componentCount}`);\n\n        const dest = this._tempBufferGetter(out.length);\n        const bytesPerElt = this._bufferType.BYTES_PER_ELEMENT;\n        const bytes = bytesPerElt*out.length;\n        const destFormatSize = this._componentCount*bytesPerElt;\n\n        _wl_mesh_get_attribute_values(this._attribute, this._formatSize, this._offset + index*this._stride,\n            this._stride, destFormatSize, dest.byteOffset, bytes);\n\n        for(let i = 0; i < out.length; ++i) out[i] = dest[i];\n        return out;\n    }\n\n    /**\n     * Set attribute element\n     * @param {number} i Index\n     * @param {number[]|Float32Array|Uint32Array} v Value to set the element to\n     *\n     * `v.length` needs to be a multiple of the attributes component count, see\n     * {@link MeshAttribute}. If `v.length` is more than one multiple, it will be\n     * filled with the next n attribute elements, which can reduce overhead\n     * of this call.\n     *\n     * @returns {MeshAttributeAccessor} Reference to self (for method chaining)\n     */\n    set(i, v) {\n        if(v.length % this._componentCount !== 0)\n            throw new Error(`out.length, ${v.length} is not a multiple of the attribute vector components, ${this._componentCount}`);\n\n        const bytesPerElt = this._bufferType.BYTES_PER_ELEMENT;\n        const bytes = bytesPerElt*v.length;\n        const srcFormatSize = this._componentCount*bytesPerElt;\n\n        /* Unless we are already working with data from WASM heap, we\n         * need to copy into temporary memory. */\n        if(v.buffer != HEAPU8.buffer) {\n            const dest = this._tempBufferGetter(v.length);\n            dest.set(v);\n            v = dest;\n        }\n\n        _wl_mesh_set_attribute_values(this._attribute, srcFormatSize, v.byteOffset, bytes,\n            this._formatSize, this._offset + i*this._stride, this._stride);\n\n        return this;\n    }\n};\nexport { MeshAttributeAccessor };\n\n/**\n * Mesh index type\n * @enum {number}\n */\nconst MeshIndexType = {\n    /** Single byte mesh index, range 0-255 */\n    UnsignedByte: 1,\n\n    /** Two byte mesh index, range 0-65535 */\n    UnsignedShort: 2,\n\n    /** Four byte mesh index, range 0-4294967295 */\n    UnsignedInt: 4,\n};\nexport { MeshIndexType };\n\n/**\n * Mesh attribute enum\n * @enum{number}\n * @since 0.9.0\n */\nconst MeshAttribute = {\n    /** Position attribute, 3 floats */\n    Position: 0,\n\n    /** Tangent attribute, 4 floats */\n    Tangent: 1,\n\n    /** Normal attribute, 3 floats */\n    Normal: 2,\n\n    /** Texture coordinate attribute, 2 floats */\n    TextureCoordinate: 3,\n\n    /** Color attribute, 4 floats, RGBA, range `0` to `1` */\n    Color: 4,\n\n    /** Joint id attribute, 4 unsigned ints */\n    JointId: 5,\n\n    /** Joint weights attribute, 4 floats */\n    JointWeight: 6,\n\n    /** Secondary joint id attribute, 4 unsigned ints */\n    SecondaryJointId: 7,\n\n    /** Secondary joint weights attribute, 4 floats */\n    SecondaryJointWeight: 8,\n};\nexport { MeshAttribute };\n\n/**\n * Wrapper around a native material\n */\nclass Material {\n    /**\n     * Create a new Material. Used internally by {@link Material.wrap}.\n     *\n     * @note Do not use this constructor directly, rather use\n     *     {@link Material#clone} or {@link Material.wrap} to create instances.\n     */\n    constructor(index) {\n        this._index = index;\n    }\n\n    /**\n     * @returns {string} Name of the shader used by this material\n     */\n    get shader() {\n        return UTF8ToString(_wl_material_get_shader(this._index));\n    }\n\n    /**\n     * Create a copy of the underlying native material and {@link Material.wrap} the result\n     * @returns {Material} Material clone\n     */\n    clone() {\n        return Material.wrap(_wl_material_clone(this._index));\n    }\n\n    _paramIndex(name) {\n        const lengthBytes = lengthBytesUTF8(name) + 1;\n        const mem = _malloc(lengthBytes);\n        stringToUTF8(name, mem, lengthBytes);\n        const index = _wl_material_get_param_index(this._index, mem);\n        _free(mem);\n        return index;\n    }\n\n    _paramType(paramIndex) {\n        const t = _wl_material_get_param_type(this._index, paramIndex);\n        return {type: (t & 0xFF), componentCount: ((t >> 8) & 0xFF), metaType: ((t >> 16) & 0xFF)};\n    }\n\n    /**\n     * Wrap a native material index\n     * @param {number} index\n     * @returns {Material} Material instance or {@link null} if index <= 0.\n     */\n    static wrap(index) {\n        if(index <= 0) return null;\n\n        const material = new Material(index);\n        return new Proxy(material, {\n            get(target, prop) {\n                const paramIndex = target._paramIndex(prop);\n                if (paramIndex != -1) {\n                    const paramType = target._paramType(paramIndex);\n                    if(_wl_material_get_param_value(target._index, paramIndex, _tempMem)) {\n                        if(paramType.type == 0) {\n                            return paramType.componentCount == 1 ? _tempMemUint32[0] : new Uint32Array(HEAPU32.buffer, _tempMem, paramType.componentCount);\n                        }\n                        if(paramType.type == 1) {\n                            return paramType.componentCount == 1 ? _tempMemInt[0] : new Int32Array(HEAP32.buffer, _tempMem, paramType.componentCount);\n                        }\n                        if(paramType.type == 2) {\n                            return paramType.componentCount == 1 ? _tempMemFloat[0] : new Float32Array(HEAPF32.buffer, _tempMem, paramType.componentCount);\n                        }\n                        if(paramType.type == 3) {\n                            return new Texture(_tempMemInt[0]);\n                        }\n                    }\n                    throw new Error(`Invalid type ${paramType} on parameter ${paramIndex} for material ${target._index}`);\n                } else {\n                    return target[prop];\n                }\n            },\n\n            set(target, prop, value) {\n                const paramIndex = target._paramIndex(prop);\n                if(paramIndex >= 0) {\n                    if(value instanceof Texture) {\n                        _wl_material_set_param_value_uint(\n                            target._index, paramIndex, value._id);\n                    } else if(typeof(value) === 'number') {\n                        _tempMemFloat[0] = value;\n                        _wl_material_set_param_value_float(\n                            target._index, paramIndex, _tempMem, 1);\n                    } else {\n                        let length = value.length;\n                        for(let i = 0; i < length; ++i) {\n                            _tempMemFloat[i] = value[i];\n                        }\n                        _wl_material_set_param_value_float(\n                            target._index, paramIndex, _tempMem, length);\n                    }\n                } else {\n                    target[prop] = value;\n                }\n                return true;\n            }\n        });\n    }\n};\nexport { Material };\n\nlet tempCanvas = null;\n\n/**\n * Wrapper around a native texture data\n */\nclass Texture {\n\n    /**\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|number} param HTML media element to create texture from or texture id to wrap.\n     */\n    constructor(param) {\n        if(param instanceof HTMLImageElement || param instanceof HTMLVideoElement || param instanceof HTMLCanvasElement) {\n            const index = _images.length;\n            _images.push(param);\n            this._imageIndex = index;\n            this._id = _wl_renderer_addImage(index);\n        } else {\n            this._id = param;\n        }\n        textures[this._id] = this;\n    }\n\n    /** @returns {boolean} Whether this texture is valid */\n    get valid() {\n        return this._id >= 0;\n    }\n\n    /** Update the texture to match the HTML element (e.g. reflect the current frame of a video) */\n    update() {\n        if(!this.valid) return;\n        _wl_renderer_updateImage(this._id, this._imageIndex);\n    }\n\n    /** @returns {int} width of the texture */\n    get width() {\n        return _wl_texture_width(this._id);\n    }\n\n    /** @returns {int} height of the texture */\n    get height() {\n        return _wl_texture_height(this._id);\n    }\n\n    /**\n     * Update a subrange on the texture to match the HTML element (e.g. reflect the current frame of a video)\n     *\n     * @param {number} x x offset\n     * @param {number} y y offset\n     * @param {number} w width\n     * @param {number} h height\n     */\n    updateSubImage(x, y, w, h) {\n        if(!this.valid) return;\n\n        /* Lazy initialize temp canvas */\n        if(!tempCanvas) tempCanvas = document.createElement('canvas');\n\n        const img = _images[this._imageIndex];\n\n        tempCanvas.width = w;\n        tempCanvas.height = h;\n        tempCanvas.getContext('2d').drawImage(img, x, y, w, h, 0, 0, w, h);\n        _images[this._imageIndex] = tempCanvas;\n\n        try {\n            _wl_renderer_updateImage(this._id,\n                this._imageIndex, x, (img.videoHeight || img.height) - y - h);\n        } finally {\n            _images[this._imageIndex] = img;\n        }\n    }\n\n    /**\n     * Destroy and free the texture's texture altas space and memory.\n     *\n     * It is best practice to set the texture variable to `null` after calling\n     * destroy to prevent accidental use of the invalid texture:\n     *\n     * @example\n     *   texture.destroy();\n     *   texture = null;\n     *\n     * @since 0.9.0\n     */\n    destroy() {\n        _wl_texture_destroy(this._id);\n        if(this._imageIndex) {\n            _images[this._imageIndex] = null;\n            this._imageIndex = undefined;\n        }\n    }\n};\nexport { Texture };\n\n/**\n * Access to the textures managed by Wonderland Engine\n */\nconst textures = {\n\n    /**\n     * Load an image from URL as {@link Texture}\n     * @param {string} filename URL to load from\n     * @param {string} crossOrigin Cross origin flag for the {@link Image} object\n     * @returns {Promise<Texture>} Loaded texture\n     */\n    load: function(filename, crossOrigin) {\n        let image = new Image();\n        if(crossOrigin !== undefined) {\n            image.crossOrigin = crossOrigin;\n        }\n        image.src = filename;\n        return new Promise((resolve, reject) => {\n            image.onload = function() {\n                let texture = new Texture(image);\n                if(!texture.valid) {\n                    reject(\"Failed to add image \" + image.src + \" to texture atlas. Probably incompatible format.\");\n                }\n                resolve(texture);\n            };\n        });\n    }\n};\n\n/**\n * Wrapper around a native animation\n */\nclass Animation {\n    constructor(index) {\n        this._index = index;\n    }\n\n    /** @returns {number} Duration of this animation */\n    get duration() {\n        return _wl_animation_get_duration(this._index);\n    }\n\n    /** @returns {number} Number of tracks in this animation */\n    get trackCount() {\n        return _wl_animation_get_trackCount(this._index);\n    }\n\n    /**\n     * Clone this animation retargeted to a new set of objects.\n     *\n     * The clone shares most of the data with the original and is therefore\n     * light-weight.\n     *\n     * **Experimental:** This API might change in upcoming versions.\n     *\n     * If retargetting to {@link Skin}, the join names will be used to determine a mapping\n     * from the previous skin to the new skin. The source skin will be retrieved from\n     * the first track in the animation that targets a joint.\n     *\n     * @param {$Object[]|Skin} newTargets New targets per track. Expected to have\n     *      {@link Animation#trackCount} elements or to be a {@link Skin}.\n     * @returns {Animation} The retargeted clone of this animation.\n     */\n    retarget(newTargets) {\n        if(newTargets instanceof Skin) {\n            const animId = _wl_animation_retargetToSkin(this._index, newTargets._index);\n            return new Animation(animId);\n        }\n\n        if(newTargets.length != this.trackCount) {\n            throw Error(\"Expected \" + this.trackCount.toString() + \" targets, but got \" + newTargets.length.toString());\n        }\n        const ptr = _malloc(2*newTargets.length);\n        for(let i = 0; i < newTargets.length; ++i) {\n            HEAPU16[ptr >> 1 + i] = newTargets[i].objectId;\n        }\n        const animId = _wl_animation_retarget(this._index, ptr);\n        _free(ptr);\n\n        return new Animation(animId);\n    }\n};\nexport { Animation };\n\n/**\n * Scene graph object\n *\n * Node in the scene graph or \"entity\". Consists of transformation and a reference\n * to its parent object. Usually holds components and is accessible by components\n * through {@link Component#object}.\n *\n * Objects are stored in a data oriented manner inside WebAssembly memory. This class\n * is a JavaScript API wrapper around this memory for more convenient use in\n * components.\n *\n * Objects can be created and added to a scene through\n * {@link Scene#addObject} on the {@link scene|main scene}.\n */\nclass $Object {\n    /**\n     * @param {number} o Object id to wrap\n     */\n    constructor(o) {\n        this.objectId = o;\n    }\n\n    /**\n     * Useful for identifying objects during debugging.\n     * @returns {string} Name of the object\n     */\n    get name() {\n        return UTF8ToString(_wl_object_name(this.objectId));\n    }\n\n    /**\n     * Set the object's name\n     * @param {string} newName String to the the object's name to\n     */\n    set name(newName) {\n        const lengthBytes = lengthBytesUTF8(newName) + 1;\n        const mem = _malloc(lengthBytes);\n        stringToUTF8(newName, mem, lengthBytes);\n        _wl_object_set_name(this.objectId, mem);\n        _free(mem);\n    }\n\n    /**\n     * @returns {$Object} Parent of this object or {@link null} if parented to root\n     */\n    get parent() {\n        const p = _wl_object_parent(this.objectId);\n        return p == 0 ? null : $Object._wrapObject(p);\n    }\n\n    /**\n     * @returns {$Object[]} Children of this object\n     */\n    get children() {\n        const childrenCount = _wl_object_get_children_count(this.objectId);\n        if(childrenCount === 0) return [];\n\n        requireTempMem(childrenCount*2);\n\n        _wl_object_get_children(this.objectId, _tempMem, _tempMemSize >> 1);\n\n        const children = new Array(childrenCount);\n        for(let i = 0; i < childrenCount; ++i) {\n            children[i] = $Object._wrapObject(_tempMemUint16[i]);\n        }\n        return children;\n    }\n\n    /**\n     * Reparent object to given object.\n     * @param {$Object} newParent New parent or {@link null} to parent to root\n     * @note Reparenting is not trivial and might have a noticeable performance impact\n     */\n    set parent(newParent) {\n        _wl_object_set_parent(this.objectId, newParent == null ? 0 : newParent.objectId);\n    }\n\n    /** Reset local transformation (translation, rotation and scaling) to identity */\n    resetTransform() {\n        _wl_object_reset_translation_rotation(this.objectId);\n        _wl_object_reset_scaling(this.objectId);\n    }\n\n    /** Reset local translation and rotation to identity */\n    resetTranslationRotation() {\n        _wl_object_reset_translation_rotation(this.objectId);\n    }\n\n    /**\n     * Reset local rotation, keep translation.\n     * @note To reset both rotation and translation, prefer\n     *       {@link $Object#resetTranslationRotation}.\n     */\n    resetRotation() {\n        _wl_object_reset_rotation(this.objectId);\n    }\n\n    /**\n     * Reset local translation, keep rotation.\n     * @note To reset both rotation and translation, prefer\n     *       {@link $Object#resetTranslationRotation}.\n     */\n    resetTranslation() {\n        _wl_object_reset_translation(this.objectId);\n    }\n\n    /** Reset local scaling to identity (``[1.0, 1.0, 1.0]``)*/\n    resetScaling() {\n        _wl_object_reset_scaling(this.objectId);\n    }\n\n    /**\n     * Translate object by a vector in the parent's space\n     * @param {number[]} v Vector to translate by\n     */\n    translate(v) {\n        _wl_object_translate(this.objectId, v[0], v[1], v[2]);\n    }\n\n    /**\n     * Translate object by a vector in object space\n     * @param {number[]} v Vector to translate by\n     */\n    translateObject(v) {\n        _wl_object_translate_obj(this.objectId, v[0], v[1], v[2]);\n    }\n\n    /**\n     * Translate object by a vector in world space\n     * @param {number[]} v Vector to translate by\n     */\n    translateWorld(v) {\n        _wl_object_translate_world(this.objectId, v[0], v[1], v[2]);\n    }\n\n    /**\n     * Rotate around given axis by given angle (degrees) in local space\n     * @param {number[]} a Vector representing the rotation axis\n     * @param {number} d Angle in degrees\n     *\n     * @note If the object is translated the rotation will be around\n     *     the parent. To rotate around the object origin, use\n     *     {@link $Object#rotateAxisAngleDegObject}\n     *\n     * @see {@link $Object#rotateAxisAngleRad}\n     */\n    rotateAxisAngleDeg(a, d) {\n        _wl_object_rotate_axis_angle(this.objectId, a[0], a[1], a[2], d);\n    }\n\n    /**\n     * Rotate around given axis by given angle (radians) in local space\n     * @param {number[]} a Vector representing the rotation axis\n     * @param {number} d Angle in degrees\n     *\n     * @note If the object is translated the rotation will be around\n     *     the parent. To rotate around the object origin, use\n     *     {@link $Object#rotateAxisAngleDegObject}\n     *\n     * @see {@link $Object#rotateAxisAngleDeg}\n     */\n    rotateAxisAngleRad(a, d) {\n        _wl_object_rotate_axis_angle_rad(this.objectId, a[0], a[1], a[2], d);\n    }\n\n    /**\n     * Rotate around given axis by given angle (degrees) in object space\n     * @param {number[]} a Vector representing the rotation axis\n     * @param {number} d Angle in degrees\n     *\n     * Equivalent to prepending a rotation quaternion to the object's\n     * local transformation.\n     *\n     * @see {@link $Object#rotateAxisAngleRadObject}\n     */\n    rotateAxisAngleDegObject(a, d) {\n        _wl_object_rotate_axis_angle_obj(this.objectId, a[0], a[1], a[2], d);\n    }\n\n    /**\n     * Rotate around given axis by given angle (radians) in object space\n     * Equivalent to prepending a rotation quaternion to the object's\n     * local transformation.\n     *\n     * @param {number[]} a Vector representing the rotation axis\n     * @param {number} d Angle in degrees\n     *\n     * @see {@link $Object#rotateAxisAngleDegObject}\n     */\n    rotateAxisAngleRadObject(a, d) {\n        _wl_object_rotate_axis_angle_rad_obj(this.objectId, a[0], a[1], a[2], d);\n    }\n\n    /**\n     * Rotate by a quaternion\n     * @param {number[]} q the Quaternion to rotate by\n     */\n    rotate(q) {\n        _wl_object_rotate_quat(this.objectId, q[0], q[1], q[2], q[3]);\n    }\n\n    /**\n     * Rotate by a quaternion in object space\n     *\n     * Equivalent to prepending a rotation quaternion to the object's\n     * local transformation.\n     *\n     * @param {number[]} q the Quaternion to rotate by\n     */\n    rotateObject(q) {\n        _wl_object_rotate_quat_obj(this.objectId, q[0], q[1], q[2], q[3]);\n    }\n\n    /**\n     * Scale object by a vector in object space\n     *\n     * @param {number[]} v Vector to scale by\n     */\n    scale(v) {\n        _wl_object_scale(this.objectId, v[0], v[1], v[2]);\n    }\n\n    /** @returns {Float32Array} Local / object space transformation */\n    get transformLocal() {\n        return new Float32Array(HEAPF32.buffer, _wl_object_trans_local(this.objectId), 8);\n    }\n\n    /**\n     * Set local transform.\n     *\n     * @param {number} t Local space transformation\n     *\n     * @since 0.8.5\n     */\n    set transformLocal(t) {\n        this.transformLocal.set(t);\n        this.setDirty();\n    }\n\n    /**\n     * Compute local / object space translation from transformation\n     * @param {number[]} out Destination array/vector, expected to have at\n     *                       least 3 elements.\n     * @return {number[]} out\n     */\n    getTranslationLocal(out) {\n        _wl_object_get_translation_local(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n        return out;\n    }\n\n    /**\n     * Compute local / object space translation from transformation\n     *\n     * May recompute transformations of the hierarchy of this object,\n     * if they were changed by JavaScript components this frame.\n     *\n     * @param {number[]} out Destination array/vector, expected to have at\n     *                       least 3 elements.\n     * @return {number[]} out\n     */\n    getTranslationWorld(out) {\n        _wl_object_get_translation_world(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n        return out;\n    }\n\n    /**\n     * Set local / object space translation\n     *\n     * Concatenates a new translation dual quaternion onto the existing rotation.\n     *\n     * @param {number[]} v New local translation array/vector, expected to\n     *                       have at least 3 elements.\n     *\n     */\n    setTranslationLocal(v) {\n        _wl_object_set_translation_local(this.objectId, v[0], v[1], v[2]);\n    }\n\n    /**\n     * Set world space translation\n     *\n     * Applies the inverse parent transform with a new translation dual quaternion\n     * which is concatenated onto the existing rotation.\n     *\n     * @param {number[]} v New world translation array/vector, expected to\n     *                       have at least 3 elements.\n     */\n    setTranslationWorld(v) {\n        _wl_object_set_translation_world(this.objectId, v[0], v[1], v[2]);\n    }\n\n    /**\n     * May recompute transformations of the hierarchy of this object,\n     * if they were changed by JavaScript components this frame.\n     *\n     * @returns {Float32Array} Global / world space transformation\n     */\n    get transformWorld() {\n        return new Float32Array(HEAPF32.buffer, _wl_object_trans_world(this.objectId), 8);\n    }\n\n    /**\n     * Set world transform.\n     *\n     * @param {number} t Global / world space transformation\n     *\n     * @since 0.8.5\n     */\n    set transformWorld(t) {\n        this.transformWorld.set(t);\n        _wl_object_trans_world_to_local(this.objectId);\n    }\n\n    /** @returns {Float32Array} Local / object space scaling */\n    get scalingLocal() {\n        return new Float32Array(HEAPF32.buffer, _wl_object_scaling_local(this.objectId), 3);\n    }\n\n    /**\n     * Set scaling local\n     *\n     * @param {number[]} t Global / world space transformation\n     *\n     * @since 0.8.7\n     */\n    set scalingLocal(s) {\n        this.scalingLocal.set(s);\n        this.setDirty();\n    }\n\n    /**\n     * @returns {Float32Array} Global / world space scaling\n     *\n     * May recompute transformations of the hierarchy of this object,\n     * if they were changed by JavaScript components this frame.\n     */\n    get scalingWorld() {\n        return new Float32Array(HEAPF32.buffer, _wl_object_scaling_world(this.objectId), 3);\n    }\n\n    /**\n     * Set scaling world\n     *\n     * @param {number[]} t Global / world space transformation\n     *\n     * @since 0.8.7\n     */\n    set scalingWorld(s) {\n        this.scalingWorld.set(s);\n        _wl_object_scaling_world_to_local(this.objectId);\n    }\n\n    /**\n     * @returns {number[]} Local space rotation\n     *\n     * @since 0.8.7\n     */\n    get rotationLocal() {\n        return this.transformLocal.subarray(0, 4);\n    }\n\n    /**\n     * @returns {number[]} Global / world space rotation\n     *\n     * @since 0.8.7\n     */\n    get rotationWorld() {\n        return this.transformWorld.subarray(0, 4);\n    }\n\n    /**\n     * Set rotation local\n     *\n     * @param {number} r Local space rotation\n     *\n     * @since 0.8.7\n     */\n    set rotationLocal(r) {\n        _wl_object_set_rotation_local(this.objectId, r[0], r[1], r[2], r[3]);\n    }\n\n    /**\n     * Set rotation world\n     *\n     * @param {number} r Global / world space rotation\n     *\n     * @since 0.8.7\n     */\n    set rotationWorld(r) {\n        _wl_object_set_rotation_world(this.objectId, r[0], r[1], r[2], r[3]);\n    }\n\n    /**\n     * Compute the object's forward facing world space vector\n     * @param {number[]} out Destination array/vector, expected to have at\n     *                       least 3 elements.\n     * @return {number[]} out\n     */\n    getForward(out) {\n        out[0] = 0; out[1] = 0; out[2] = -1;\n        this.transformVectorWorld(out);\n        return out;\n    }\n\n    /**\n     * Compute the object's up facing world space vector\n     * @param {number[]} out Destination array/vector, expected to have at\n     *                       least 3 elements.\n     * @return {number[]} out\n     */\n    getUp(out) {\n        out[0] = 0; out[1] = 1; out[2] = 0;\n        this.transformVectorWorld(out);\n        return out;\n    }\n\n    /**\n     * Compute the object's right facing world space vector\n     * @param {number[]} out Destination array/vector, expected to have at\n     *                       least 3 elements.\n     * @return {number[]} out\n     */\n    getRight(out) {\n        out[0] = 1; out[1] = 0; out[2] = 0;\n        this.transformVectorWorld(out);\n        return out;\n    }\n\n    /**\n     * Transform a vector by this object's world transform\n     *\n     * @param {number[]} out Out point\n     * @param {number[]} v Point to transform, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    transformVectorWorld(out, v) {\n        v = v || out;\n        _tempMemFloat[0] = v[0];\n        _tempMemFloat[1] = v[1];\n        _tempMemFloat[2] = v[2];\n        _wl_object_transformVectorWorld(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n\n        return out;\n    }\n\n    /**\n     * Transform a vector by this object's local transform\n     *\n     * @param {number[]} out Out point\n     * @param {number[]} v Point to transform, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    transformVectorLocal(out, v) {\n        v = v || out;\n        _tempMemFloat[0] = v[0];\n        _tempMemFloat[1] = v[1];\n        _tempMemFloat[2] = v[2];\n        _wl_object_transformVectorLocal(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n\n        return out;\n    }\n\n    /**\n     * Transform a point by this object's world transform\n     *\n     * @param {number[]} out Out point\n     * @param {number[]} v Point to transform, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    transformPointWorld(out, p) {\n        p = p || out;\n        _tempMemFloat[0] = p[0];\n        _tempMemFloat[1] = p[1];\n        _tempMemFloat[2] = p[2];\n        _wl_object_transformPointWorld(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n\n        return out;\n    }\n\n    /**\n     * Transform a point by this object's local transform\n     *\n     * @param {number[]} out Out point\n     * @param {number[]} v Point to transform, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    transformPointLocal(out, p) {\n        p = p || out;\n        _tempMemFloat[0] = p[0];\n        _tempMemFloat[1] = p[1];\n        _tempMemFloat[2] = p[2];\n        _wl_object_transformPointLocal(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n\n        return out;\n    }\n\n    /**\n     * Transform a vector by this object's inverse world transform\n     *\n     * @param {number[]} out Out point\n     * @param {number[]} v Point to transform, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    transformVectorInverseWorld(out, v) {\n        v = v || out;\n        _tempMemFloat[0] = v[0];\n        _tempMemFloat[1] = v[1];\n        _tempMemFloat[2] = v[2];\n        _wl_object_transformVectorInverseWorld(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n\n        return out;\n    }\n\n    /**\n     * Transform a point by this object's inverse local transform\n     *\n     * @param {number[]} out Out point\n     * @param {number[]} v Point to transform, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    transformVectorInverseLocal(out, v) {\n        v = v || out;\n        _tempMemFloat[0] = v[0];\n        _tempMemFloat[1] = v[1];\n        _tempMemFloat[2] = v[2];\n        _wl_object_transformVectorInverseLocal(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n\n        return out;\n    }\n\n    /**\n     * Transform a point by this object's inverse world transform\n     *\n     * @param {number[]} out Out point\n     * @param {number[]} v Point to transform, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    transformPointInverseWorld(out, p) {\n        p = p || out;\n        _tempMemFloat[0] = p[0];\n        _tempMemFloat[1] = p[1];\n        _tempMemFloat[2] = p[2];\n        _wl_object_transformPointInverseWorld(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n\n        return out;\n    }\n\n    /**\n     * Transform a point by this object's inverse local transform\n     *\n     * @param {number[]} out Out point\n     * @param {number[]} p Point to transform, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    transformPointInverseLocal(out, p) {\n        p = p || out;\n        _tempMemFloat.set(p);\n        _wl_object_transformPointInverseLocal(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n\n        return out;\n    }\n\n    /**\n     * Transform a object space dual quaternion into world space\n     *\n     * @param {number[]} out Out transformation\n     * @param {number[]} q Local space transformation, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    toWorldSpaceTransform(out, q) {\n        q = q || out;\n        _tempMemFloat.set(q);\n        _wl_object_toWorldSpaceTransform(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n        out[3] = _tempMemFloat[3];\n\n        out[4] = _tempMemFloat[4];\n        out[5] = _tempMemFloat[5];\n        out[6] = _tempMemFloat[6];\n        out[7] = _tempMemFloat[7];\n\n        return out;\n    }\n\n    /**\n     * Transform a world space dual quaternion into local space\n     *\n     * @param {number[]} out Out transformation\n     * @param {number[]} q World space transformation, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    toLocalSpaceTransform(out, q) {\n        const p = this.parent;\n        if(!p) {\n            out[0] = q[0]; out[1] = q[1]; out[2] = q[2]; out[3] = q[3];\n            out[4] = q[4]; out[5] = q[5]; out[6] = q[6]; out[7] = q[7];\n        } else {\n            p.toObjectSpaceTransform(q);\n        }\n        return out;\n    }\n\n    /**\n     * Transform a world space dual quaternion into object space\n     *\n     * @param {number[]} out Out transformation\n     * @param {number[]} q World space transformation, default `out`\n     * @return {number[]} out\n     *\n     * @since 0.8.7\n     */\n    toObjectSpaceTransform(out, q) {\n        q = q || out;\n        _tempMemFloat.set(q);\n        _wl_object_toObjectSpaceTransform(this.objectId, _tempMem);\n        out[0] = _tempMemFloat[0];\n        out[1] = _tempMemFloat[1];\n        out[2] = _tempMemFloat[2];\n        out[3] = _tempMemFloat[3];\n\n        out[4] = _tempMemFloat[4];\n        out[5] = _tempMemFloat[5];\n        out[6] = _tempMemFloat[6];\n        out[7] = _tempMemFloat[7];\n\n        return out;\n    }\n\n    /**\n     * Turn towards / look at target\n     * @param {number[]} v Target vector to turn towards\n     * @param {number[]} up Up vector of this object, default `[0, 1, 0]`\n     */\n    lookAt(v, up=[0, 1, 0]) {\n        _wl_object_lookAt(this.objectId,\n            v[0], v[1], v[2], up[0], up[1], up[2]);\n    }\n\n    /** Destroy the object with all of its components and remove it from the scene */\n    destroy() {\n        _wl_scene_remove_object(this.objectId);\n        this.objectId = null;\n    }\n\n    /**\n     * Mark transformation dirty\n     *\n     * Causes an eventual recalculation of {@link $Object#transformWorld}, either\n     * on next {@link $Object#getTranslationWorld}, {@link $Object#transformWorld} or\n     * {@link $Object#scalingWorld} or the beginning of next frame, whichever\n     * happens first.\n     */\n    setDirty() {\n        _wl_object_set_dirty(this.objectId);\n    }\n\n    /**\n     * Disable/enable all components of this object\n     *\n     * @param {boolean} b New state for the components\n     * @since 0.8.5\n     */\n    set active(b) {\n        const comps = this.getComponents();\n        for(let c of comps) {\n            c.active = b;\n        }\n    }\n\n    /**\n     * Get a component attached to this object\n     * @param {string|Function} typeOrClass Type name. It's also possible to give a class definition.\n     *     In this case, the method will use the `class.TypeName` field to find the component.\n     * @param {number} index=0 Index for component of given type. This can be used to access specific\n     *      components if the object has multiple components of the same type.\n     * @returns {?(Component|CollisionComponent|TextComponent|ViewComponent|MeshComponent|InputComponent|LightComponent|AnimationComponent|PhysXComponent)} The component or {@link null} if there is no such component on this object\n     */\n    getComponent(typeOrClass, index) {\n        const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;\n        const lengthBytes = lengthBytesUTF8(type) + 1;\n        const mem = _malloc(lengthBytes);\n        stringToUTF8(type, mem, lengthBytes);\n        const componentType = _wl_get_component_manager_index(mem);\n        _free(mem);\n\n        if(componentType < 0) {\n            /* Not a native component, try js: */\n            const typeIndex = _WL._componentTypeIndices[type];\n            const jsIndex = _wl_get_js_component_index(this.objectId, typeIndex, index || 0);\n            return jsIndex < 0 ? null : _WL._components[jsIndex];\n        }\n\n        const componentId = _wl_get_component_id(this.objectId, componentType, index || 0);\n        return _wrapComponent(type, componentType, componentId);\n    }\n\n    /**\n     * @param {?string|Function} typeOrClass Type name, pass a falsey value (`undefined` or {@link null}) to retrieve all.\n     *     It's also possible to give a class definition. In this case, the method will use the `class.TypeName` field to\n     *     find the components.\n     * @returns {Component[]} All components of given type attached to this object\n     *\n     * @note As this function is non-trivial, avoid using it in `update()` repeatedly,\n     *      but rather store its result in `init()` or `start()`\n     * @warning This method will currently return at most 341 components.\n     */\n    getComponents(typeOrClass) {\n        let componentType = null;\n        let type = null;\n        if(typeOrClass) {\n            type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;\n            componentType = $Object._typeIndexFor(type);\n        }\n        const components = [];\n        const maxComps = Math.floor(_tempMemSize/3*2);\n        const componentsCount =\n            _wl_object_get_components(this.objectId, _tempMem, maxComps);\n        const offset = 2*componentsCount;\n        _wl_object_get_component_types(this.objectId, _tempMem + offset, maxComps);\n\n        const jsManagerIndex = $Object._typeIndexFor('js');\n        for(let i = 0; i < componentsCount; ++i) {\n            const t = _tempMemUint8[i + offset];\n            const componentId = _tempMemUint16[i];\n            /* Handle JS types separately */\n            if(t == jsManagerIndex) {\n                const comp = _WL._components[_wl_get_js_component_index_for_id(componentId)];\n                if(componentType === null || comp.type == type) components.push(comp);\n                continue;\n            }\n\n            if(componentType === null) {\n                const managerName = $Object._typeNameFor(t);\n                components.push(_wrapComponent(managerName, t, componentId));\n            } else if(t == componentType) {\n                /* Optimized manager name retrieval, already have type */\n                components.push(_wrapComponent(type, componentType, componentId));\n            }\n        }\n        return components;\n    }\n\n    /**\n     * Add component of given type to the object\n     *\n     * You can use this function to clone components, see the example below.\n     *\n     * @example\n     *  // Clone existing component (since 0.8.10)\n     *  let original = this.object.getComponent('mesh');\n     *  otherObject.addComponent('mesh', original);\n     *  // Create component from parameters\n     *  this.object.addComponent('mesh', {\n     *      mesh: someMesh,\n     *      material: someMaterial,\n     *  });\n     *\n     * @param {string|Function} typeOrClass Typename to create a component of. Can be native or\n     *     custom JavaScript component type. It's also possible to give a class definition.\n     *     In this case, the method will use the `class.TypeName` field.\n     * @param {object} [params] Parameters to initialize properties of the new component,\n     *      can be another component to copy properties from.\n     *\n     * @returns {?(Component|CollisionComponent|TextComponent|ViewComponent|MeshComponent|InputComponent|LightComponent|AnimationComponent|PhysXComponent)} The component or {@link null} if the type was not found\n     */\n    addComponent(typeOrClass, params) {\n        const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;\n        const componentType = $Object._typeIndexFor(type);\n        let component = null;\n        let componentIndex = null;\n        if(componentType < 0) {\n            /* JavaScript component */\n            if(!(type in _WL._componentTypeIndices)) {\n                throw new TypeError(\"Unknown component type '\" + type + \"'\");\n            }\n            const componentId = _wl_object_add_js_component(this.objectId, _WL._componentTypeIndices[type]);\n            componentIndex = _wl_get_js_component_index_for_id(componentId);\n            component = _WL._components[componentIndex];\n        } else {\n            /* native component */\n            const componentId = _wl_object_add_component(this.objectId, componentType);\n            component = _wrapComponent(type, componentType, componentId);\n        }\n\n        if(params !== undefined) {\n            for(const key in params) {\n                /* active will be set later, other properties should be skipped if\n                 * passing a component for cloning. */\n                if(EXCLUDED_COMPONENT_PROPERTIES.includes(key)) continue;\n                component[key] = params[key];\n            }\n        }\n\n        /* Explicitly initialize native components */\n        if(componentType < 0) {\n            _wljs_component_init(componentIndex);\n            /* start() is called through onActivate() */\n        }\n\n        /* If it was not explicitly requested by the user to leave the component inactive,\n         * we activate it as a final step. This invalidates componentIndex! */\n        if(!params || !('active' in params && !params.active)) {\n            component.active = true;\n        }\n\n        return component;\n    }\n\n    /**\n     * @returns {boolean} Whether given object's transformation has changed.\n     */\n    get changed() {\n        return !!_wl_object_is_changed(this.objectId);\n    }\n\n    /**\n     * Checks equality by comparing whether the wrapped native component ids\n     * and component manager types are equal.\n     *\n     * @param {?$Object} otherObject Object to check equality with\n     * @returns {boolean} Whether this object equals the given object\n     */\n    equals(otherObject) {\n        if(!otherObject) return false;\n        return this.objectId == otherObject.objectId;\n    }\n\n    static _typeIndexFor(type) {\n        const lengthBytes = lengthBytesUTF8(type) + 1;\n        const mem = _malloc(lengthBytes);\n        stringToUTF8(type, mem, lengthBytes);\n        const componentType = _wl_get_component_manager_index(mem);\n        _free(mem);\n\n        return componentType;\n    }\n\n    static _typeNameFor(typeIndex) {\n        return UTF8ToString(_wl_component_manager_name(typeIndex));\n    }\n\n    /*\n     * @param {number} objectId Object ID to wrap\n     * @returns {$Object} Wrapped object\n     */\n    static _wrapObject(objectId) {\n        const o = ObjectCache[objectId] || (ObjectCache[objectId] = new $Object(objectId));\n        o.objectId = objectId;\n        return o;\n    }\n};\n\n/**\n * Wrapper around a native skin data\n */\nclass Skin {\n    constructor(index) {\n        this._index = index;\n    }\n\n    /** @returns {number} amount of joints in this skin */\n    get jointCount() {\n        return _wl_skin_get_joint_count(this._index);\n    }\n\n    /** @returns {Uint16Array} joints object ids for this skin */\n    get jointIds() {\n        return new Uint16Array(HEAPU16.buffer,\n            _wl_skin_joint_ids(this._index), this.jointCount);\n    }\n\n    /**\n     * Dual quaternions in a flat array of size 8 times {@link Skin#jointCount}\n     *\n     * @returns {Float32Array} Inverse bind transforms of the skin\n     */\n    get inverseBindTransforms() {\n        return new Float32Array(HEAPF32.buffer,\n            _wl_skin_inverse_bind_transforms(this._index),\n            8*this.jointCount);\n    }\n\n    /**\n     * Vectors in a flat array of size 3 times {@link Skin#jointCount}\n     *\n     * @returns {Float32Array} Inverse bind scalings of the skin\n     */\n    get inverseBindScalings() {\n        return new Float32Array(HEAPF32.buffer,\n            _wl_skin_inverse_bind_scalings(this._index),\n            3*this.jointCount);\n    }\n};\nexport { Skin };\n/* Unfortunately, the name \"Object\" is reserved, so internally we\n * use $Object, while we expose WL.Object as previously. */\nexport { $Object as Object };\n\n/**\n * @summary Ray hit\n *\n * Result of a {@link Scene#rayCast|ray cast}\n *\n * @param {number} ptr Pointer to the ray hits memory\n * @note this class wraps internal engine data and should only be created\n * internally.\n */\nclass RayHit {\n    constructor(ptr) {\n        assert((this._ptr & 3) == 0, MISALIGNED_MSG);\n        this._ptr = ptr;\n    }\n\n    /** @returns {Float32Array[]} array of ray hit locations */\n    get locations() {\n        let p = this._ptr;\n        let l = [];\n        for(let i = 0; i < this.hitCount; ++i) {\n            l.push(new Float32Array(HEAPF32.buffer, p + 12*i, 3));\n        }\n        return l;\n    }\n\n    /** @returns {Float32Array[]} array of ray hit normals (only when using {@link Physics#rayCast} */\n    get normals() {\n        let p = this._ptr + 48;\n        let l = [];\n        for(let i = 0; i < this.hitCount; ++i) {\n            l.push(new Float32Array(HEAPF32.buffer, p + 12*i, 3));\n        }\n        return l;\n    }\n\n    /**\n     * Prefer these to recalculating the distance from locations.\n     *\n     * @returns {number} Distances of array hits to ray origin\n     */\n    get distances() {\n        let p = this._ptr + 48*2;\n        return new Float32Array(HEAPF32.buffer, p, this.hitCount);\n    }\n\n    /** @returns {$Object[]} Hit objects */\n    get objects() {\n        let p = this._ptr + (48*2 + 16);\n        let objIds = new Uint16Array(HEAPU16.buffer, p, this.hitCount);\n        return [\n            objIds[0] <= 0 ? null : $Object._wrapObject(objIds[0]),\n            objIds[1] <= 0 ? null : $Object._wrapObject(objIds[1]),\n            objIds[2] <= 0 ? null : $Object._wrapObject(objIds[2]),\n            objIds[3] <= 0 ? null : $Object._wrapObject(objIds[3]),\n        ];\n    }\n\n    /** @returns {number} Number of hits (max 4) */\n    get hitCount() {\n        return Math.min(HEAPU32[(this._ptr/4) + 30], 4);\n    }\n};\nexport { RayHit };\n\nclass math {\n    /** (Experimental!) Cubic Hermite spline interpolation for vector3 and quaternions.\n     *\n     * With `f == 0`, `out` will be `b`, if `f == 1`, `out` will be c.\n     *\n     * Whether a quaternion or vector3 interpolation is intended is determined by\n     * length of `a`.\n     *\n     * @param {number[]} out Array to write result to\n     * @param {number[]} a First tangent/handle\n     * @param {number[]} b First point or quaternion\n     * @param {number[]} c Second point or quaternion\n     * @param {number[]} d Second handle\n     * @param {number} f Interpolation factor in [0; 1]\n     * @returns {number[]} out\n     * @since 0.8.6\n     */\n    static cubicHermite(out, a, b, c, d, f) {\n        _tempMemFloat.subarray(0).set(a);\n        _tempMemFloat.subarray(4).set(b);\n        _tempMemFloat.subarray(8).set(c);\n        _tempMemFloat.subarray(12).set(d);\n\n        const isQuat = a.length == 4;\n\n        _wl_math_cubicHermite(\n            _tempMem + 4*16,\n            _tempMem + 4*0,\n            _tempMem + 4*4,\n            _tempMem + 4*8,\n            _tempMem + 4*12,\n            f, isQuat);\n        out[0] = _tempMemFloat[16];\n        out[1] = _tempMemFloat[17];\n        out[2] = _tempMemFloat[18];\n        if(isQuat) out[3] = _tempMemFloat[19];\n        return out;\n    }\n}\n\nexport { math }\n\n/**\n * Check if a given value is a native string or a `String` instance\n *\n * @param {Object} value The value to check\n * @returns `true` if the `value` has type string literal or `String`, `false` otherwise\n */\nexport function isString(value) {\n    return value && (typeof value === 'string' || value.constructor === String);\n}\n\n/**\n * Retrieves a component instance if it exists, or create and cache\n * a new one\n *\n * @param {string} type component type name\n * @param {number} componentType Component manager index\n * @param {number} componentId Component id in the manager\n *\n * @returns {(CollisionComponent|TextComponent|ViewComponent|MeshComponent|InputComponent|LightComponent|AnimationComponent|PhysXComponent|Component)} JavaScript instance wrapping the native component\n */\nexport function _wrapComponent(type, componentType, componentId) {\n    if(componentId < 0) return null;\n\n    /* TODO: extremely slow in JS to do that... Better to use a Map or allocate the array. */\n    const c = ComponentCache[componentType] || (ComponentCache[componentType] = []);\n    if(c[componentId]) { return c[componentId]; }\n\n    let component;\n    if(type == 'collision') {\n        component = new CollisionComponent();\n    } else if(type == 'text') {\n        component = new TextComponent();\n    } else if(type == 'view') {\n        component = new ViewComponent();\n    } else if(type == 'mesh') {\n        component = new MeshComponent();\n    } else if(type == 'input') {\n        component = new InputComponent();\n    } else if(type == 'light') {\n        component = new LightComponent();\n    } else if(type == 'animation') {\n        component = new AnimationComponent();\n    } else if(type == 'physx') {\n        component = new PhysXComponent();\n    } else {\n        const typeIndex = _WL._componentTypeIndices[type];\n        const constructor =  _WL._componentTypes[typeIndex];\n        component = new constructor();\n    }\n    /* Sets the manager and identifier from the outside, to\n     * simplify the user's constructor. */\n    component._manager = componentType;\n    component._id = componentId;\n    c[componentId] = component;\n    return component;\n}\n"],
  "mappings": "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",
  "names": []
}
